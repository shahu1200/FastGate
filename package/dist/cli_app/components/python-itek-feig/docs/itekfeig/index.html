<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>itekfeig API documentation</title>
<meta name="description" content="i-Tek Feig UHF reader library" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>itekfeig</code></h1>
</header>
<section id="section-intro">
<p>i-Tek Feig UHF reader library</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
i-Tek Feig UHF reader library
&#34;&#34;&#34;

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from .version import version

from .common.feig_logger import FeigLogger
from .common.feig_errors import FeigError

from .readers.LRU1002 import LRU1002
from .readers.HyWear import HyWear
from .readers.MRU102 import MRU102
from .readers.LRU500i import LRU500i

# from .gs1 import sgtin96_decoder
from .gs1 import sgtin96_to_ean
from .gs1 import tid_parser
from .gs1 import gtin_check

SUPPORTED_READERS = [
    &#34;LRU1002&#34;,
    &#34;MRU102&#34;,
    &#34;MU02&#34;,
    &#34;LRU500iPOE&#34;,
    &#34;LRU500iBD&#34;,
    &#34;HyWear&#34;,
]
&#34;&#34;&#34;List of supported readers.&#34;&#34;&#34;

class ReaderNotSupportedError(Exception):
    &#34;&#34;&#34;Reader Not Supported&#34;&#34;&#34;
    pass


def FeigReader(reader: str):
    &#34;&#34;&#34;Returns reader object from given reader name.

    Args:
        reader: name of the reader in SUPPORTED_READERS

    Raises:
        ReaderNotSupportedError
    &#34;&#34;&#34;
    if reader not in SUPPORTED_READERS:
        raise ReaderNotSupportedError

    if reader == &#34;LRU1002&#34;:
        return LRU1002()

    if reader == &#34;MRU102&#34;:
        return MRU102()

    if reader == &#34;LRU500iPOE&#34;:
        return LRU500i(&#34;poe&#34;)

    if reader == &#34;LRU500iBD&#34;:
        return LRU500i(&#34;bd&#34;)

    if reader == &#34;HyWear&#34;:
        return HyWear()


__all__ = [
    &#34;version&#34;,
    &#34;SUPPORTED_READERS&#34;,
    &#34;FeigReader&#34;,
    &#34;FeigLogger&#34;,
    &#34;FeigError&#34;,
    &#34;LRU1002&#34;,
    &#34;HyWear&#34;,
    &#34;MRU102&#34;,
    &#34;LRU500i&#34;,
    #&#39;sgtin96_decoder&#39;,
    &#34;tid_parser&#34;,
    &#34;sgtin96_to_ean&#34;,
    &#34;gtin_check&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="itekfeig.common" href="common/index.html">itekfeig.common</a></code></dt>
<dd>
<div class="desc"><p>Contains common code required by most readers</p></div>
</dd>
<dt><code class="name"><a title="itekfeig.gs1" href="gs1.html">itekfeig.gs1</a></code></dt>
<dd>
<div class="desc"><p>Tool used to parse SGTIN-96 hex string from RFID tags.
SGTIN Format (bits):
Header
Filter
Partition
Company Prefix
Item Reference
Serial
8 â€¦</p></div>
</dd>
<dt><code class="name"><a title="itekfeig.interface" href="interface/index.html">itekfeig.interface</a></code></dt>
<dd>
<div class="desc"><p>Contains all FEIG interfaces</p></div>
</dd>
<dt><code class="name"><a title="itekfeig.readers" href="readers/index.html">itekfeig.readers</a></code></dt>
<dd>
<div class="desc"><p>Contains all FEIG readers</p></div>
</dd>
<dt><code class="name"><a title="itekfeig.version" href="version.html">itekfeig.version</a></code></dt>
<dd>
<div class="desc"><p>Current module/library version</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="itekfeig.SUPPORTED_READERS"><code class="name">var <span class="ident">SUPPORTED_READERS</span></code></dt>
<dd>
<div class="desc"><p>List of supported readers.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="itekfeig.FeigLogger"><code class="name flex">
<span>def <span class="ident">FeigLogger</span></span>(<span>loggerName=None, loggerPath=None, loggerLevel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create logger instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loggerName</code></strong></dt>
<dd>str or None, None = root logger</dd>
<dt><strong><code>loggerPath</code></strong></dt>
<dd>str =&gt; path of the logger file, Defaults to $HOME directory</dd>
<dt><strong><code>loggerLevel</code></strong></dt>
<dd>int or 'logging' module log levels, Defaults to logging.NOTSET</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logger</code></dt>
<dd>object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FeigLogger(loggerName=None, loggerPath=None, loggerLevel=None):
    &#34;&#34;&#34;Create logger instance.

    Args:
        loggerName: str or None, None = root logger
        loggerPath: str =&gt; path of the logger file, Defaults to $HOME directory
        loggerLevel: int or &#39;logging&#39; module log levels, Defaults to logging.NOTSET

    Returns:
        logger: object
    &#34;&#34;&#34;

    # If path is empty, log to home directory
    if loggerPath is None:
        # for python 3.5+
        from pathlib import Path

        loggerPath = str(Path.home())
    loggerPath = os.path.join(loggerPath, LOG_FILE_NAME)

    logger = logging.getLogger(loggerName)

    # Set Log level
    level = logging.NOTSET  # Default
    if isinstance(loggerLevel, int):
        if loggerLevel == logging.CRITICAL:
            level = logging.CRITICAL

        elif loggerLevel == logging.ERROR:
            level = logging.ERROR

        elif loggerLevel == logging.WARNING:
            level = logging.WARNING

        elif loggerLevel == logging.INFO:
            level = logging.INFO

        elif loggerLevel == logging.DEBUG:
            level = logging.DEBUG
    logger.setLevel(level)

    formatter = logging.Formatter(&#34;%(asctime)s::%(levelname)s::%(name)s::%(message)s&#34;)

    # timed logger
    timedHandler = handlers.TimedRotatingFileHandler(
        loggerPath, when=&#34;midnight&#34;, interval=1, backupCount=5,
    )
    timedHandler.setFormatter(formatter)
    logger.addHandler(timedHandler)

    # stream logger
    console = logging.StreamHandler()
    console.setFormatter(formatter)
    logger.addHandler(console)

    return logger</code></pre>
</details>
</dd>
<dt id="itekfeig.FeigReader"><code class="name flex">
<span>def <span class="ident">FeigReader</span></span>(<span>reader:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns reader object from given reader name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reader</code></strong></dt>
<dd>name of the reader in SUPPORTED_READERS</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ReaderNotSupportedError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FeigReader(reader: str):
    &#34;&#34;&#34;Returns reader object from given reader name.

    Args:
        reader: name of the reader in SUPPORTED_READERS

    Raises:
        ReaderNotSupportedError
    &#34;&#34;&#34;
    if reader not in SUPPORTED_READERS:
        raise ReaderNotSupportedError

    if reader == &#34;LRU1002&#34;:
        return LRU1002()

    if reader == &#34;MRU102&#34;:
        return MRU102()

    if reader == &#34;LRU500iPOE&#34;:
        return LRU500i(&#34;poe&#34;)

    if reader == &#34;LRU500iBD&#34;:
        return LRU500i(&#34;bd&#34;)

    if reader == &#34;HyWear&#34;:
        return HyWear()</code></pre>
</details>
</dd>
<dt id="itekfeig.gtin_check"><code class="name flex">
<span>def <span class="ident">gtin_check</span></span>(<span>ean:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify EAN/GTIN-8,13 by checking its CHECK digit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gtin_check(ean: str) -&gt; bool:
    &#34;&#34;&#34;Verify EAN/GTIN-8,13 by checking its CHECK digit&#34;&#34;&#34;
    ean_len = len(ean)
    if ean_len in (8, 13):
        check_digit = int(ean[-1])
        if gtin_check_digit(ean[:-1]) == check_digit:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.sgtin96_to_ean"><code class="name flex">
<span>def <span class="ident">sgtin96_to_ean</span></span>(<span>sgtin96:Â str) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns EAN and SerialNumber from SGTIN96</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sgtin96_to_ean(sgtin96: str) -&gt; tuple:
    &#34;&#34;&#34;Returns EAN and SerialNumber from SGTIN96&#34;&#34;&#34;
    (company_prefix, item_reference, serialno) = sgtin96_decoder(sgtin96)
    ean = company_prefix + item_reference[1:6]
    ean = ean + str(gtin_check_digit(ean))
    srno = serialno.zfill(12)

    return (ean, srno)</code></pre>
</details>
</dd>
<dt id="itekfeig.tid_parser"><code class="name flex">
<span>def <span class="ident">tid_parser</span></span>(<span>tid:Â str) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Parse given TID (hex-str)</p>
<p>Ref: <a href="https://www.gs1.org/standards/epcrfid-epcis-id-keys/epc-rfid-tds/1-13">https://www.gs1.org/standards/epcrfid-epcis-id-keys/epc-rfid-tds/1-13</a></p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>parse xtid</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tid_parser(tid: str) -&gt; dict:
    &#34;&#34;&#34;Parse given TID (hex-str)

    Ref: https://www.gs1.org/standards/epcrfid-epcis-id-keys/epc-rfid-tds/1-13

    .. TODO:: parse xtid
    &#34;&#34;&#34;
    data = {}
    tid_bytes = bytes.fromhex(tid)

    # ISO/IEC 15963 allocation class identifier of E2
    if len(tid_bytes) == 12 and tid_bytes[0] == 0xE2:
        extend_bit = bool(tid_bytes[1] &amp; 0x80)
        security_bit = bool(tid_bytes[1] &amp; 0x40)
        file_bit = bool(tid_bytes[1] &amp; 0x20)

        mdid = tid_bytes[1] &amp; 0x1F
        mdid = (mdid &lt;&lt; 4) + ((tid_bytes[2] &amp; 0xF0) &gt;&gt; 4)

        tmn = tid_bytes[2] &amp; 0x0F
        tmn = tmn * 256 + tid_bytes[3]

        sr_no = bytes.hex(tid_bytes[6:])

        data[&#34;extend_indicator&#34;] = extend_bit
        data[&#34;security_indicator&#34;] = security_bit
        data[&#34;file_indicator&#34;] = file_bit
        data[&#34;mask_designer_id&#34;] = mdid
        data[&#34;tag_model_number&#34;] = tmn
        data[&#34;tag_serial_number&#34;] = sr_no

        if extend_bit is True:
            xtid = bytes.hex(tid_bytes[4:6])
            data[&#34;xtid&#34;] = xtid
            # TODO: parse xtid

    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="itekfeig.FeigError"><code class="flex name class">
<span>class <span class="ident">FeigError</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Feig Errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeigError(enum.IntEnum):
    &#34;&#34;&#34;Feig Errors&#34;&#34;&#34;
    OK = 0

    # LIBRARY Specific
    COMM_TIMEOUT = 1  # When response is not receive in time
    INVALID_RESPONSE = 2  # Response from reader is NOT as expected
    INVALID_READER = 3  # Connected reader is NOT as expected
    EPC_LEN_MISMATCH = 4  # When read/write operation on tag, EPC must be EVEN length
    MODE_SAME = 5  # Requested reader mode and current mode is SAME
    INVALID_MODE = 6  # Some commnads require reader to be in specific mode only
    INVALID_INTERFACE = 7  # Some commnads require reader to be in specific interface only

    NO_ROUTE_TO_HOST = 8
    CONNECTION_REFUSED = 9
    UNHANDLED = 10

    SERIAL = 11
    ETHERNET = 12

    INTERFACE_ERROR = 13

    # FEIG Specific ERROR/STATUS
    NO_TAG = 50
    DATA_FALSE = 51
    WRITE_ERROR = 52
    ADDRESS_ERROR = 53
    WRONG_TRANSPONDER_TYPE = 54
    AUTHENT_ERROR = 55
    EEPROM_FAILURE = 56
    PARAMETER_RANGE_ERROR = 57
    LOGIN_REQUEST = 58
    LOGIN_ERROR = 59
    READ_PROTECT = 60
    WRITE_PROTECT = 61
    FIRMWARE_ACTIVATION_REQUIRED = 62
    WRONG_FIRMWARE = 63

    UNKNOWN_COMMAND = 0x80
    LENGTH_ERROR = 0x81
    COMMAND_NOT_AVAILABLE = 0x82
    RF_COMMUNICATION_ERROR = 0x83
    RF_WARNING = 0x84

    NO_VALID_DATA = 0x92
    DATA_BUFFER_OVERFLOW = 0x93
    MORE_DATA = 0x94
    TAG_ERROR = 0x95

    HARDWARE_WARNING = 0xF1

    UNKNOWN = 255</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="itekfeig.FeigError.ADDRESS_ERROR"><code class="name">var <span class="ident">ADDRESS_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.AUTHENT_ERROR"><code class="name">var <span class="ident">AUTHENT_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.COMMAND_NOT_AVAILABLE"><code class="name">var <span class="ident">COMMAND_NOT_AVAILABLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.COMM_TIMEOUT"><code class="name">var <span class="ident">COMM_TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.CONNECTION_REFUSED"><code class="name">var <span class="ident">CONNECTION_REFUSED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.DATA_BUFFER_OVERFLOW"><code class="name">var <span class="ident">DATA_BUFFER_OVERFLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.DATA_FALSE"><code class="name">var <span class="ident">DATA_FALSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.EEPROM_FAILURE"><code class="name">var <span class="ident">EEPROM_FAILURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.EPC_LEN_MISMATCH"><code class="name">var <span class="ident">EPC_LEN_MISMATCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.ETHERNET"><code class="name">var <span class="ident">ETHERNET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.FIRMWARE_ACTIVATION_REQUIRED"><code class="name">var <span class="ident">FIRMWARE_ACTIVATION_REQUIRED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.HARDWARE_WARNING"><code class="name">var <span class="ident">HARDWARE_WARNING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.INTERFACE_ERROR"><code class="name">var <span class="ident">INTERFACE_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.INVALID_INTERFACE"><code class="name">var <span class="ident">INVALID_INTERFACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.INVALID_MODE"><code class="name">var <span class="ident">INVALID_MODE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.INVALID_READER"><code class="name">var <span class="ident">INVALID_READER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.INVALID_RESPONSE"><code class="name">var <span class="ident">INVALID_RESPONSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.LENGTH_ERROR"><code class="name">var <span class="ident">LENGTH_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.LOGIN_ERROR"><code class="name">var <span class="ident">LOGIN_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.LOGIN_REQUEST"><code class="name">var <span class="ident">LOGIN_REQUEST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.MODE_SAME"><code class="name">var <span class="ident">MODE_SAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.MORE_DATA"><code class="name">var <span class="ident">MORE_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.NO_ROUTE_TO_HOST"><code class="name">var <span class="ident">NO_ROUTE_TO_HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.NO_TAG"><code class="name">var <span class="ident">NO_TAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.NO_VALID_DATA"><code class="name">var <span class="ident">NO_VALID_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.OK"><code class="name">var <span class="ident">OK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.PARAMETER_RANGE_ERROR"><code class="name">var <span class="ident">PARAMETER_RANGE_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.READ_PROTECT"><code class="name">var <span class="ident">READ_PROTECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.RF_COMMUNICATION_ERROR"><code class="name">var <span class="ident">RF_COMMUNICATION_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.RF_WARNING"><code class="name">var <span class="ident">RF_WARNING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.SERIAL"><code class="name">var <span class="ident">SERIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.TAG_ERROR"><code class="name">var <span class="ident">TAG_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.UNHANDLED"><code class="name">var <span class="ident">UNHANDLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.UNKNOWN_COMMAND"><code class="name">var <span class="ident">UNKNOWN_COMMAND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.WRITE_ERROR"><code class="name">var <span class="ident">WRITE_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.WRITE_PROTECT"><code class="name">var <span class="ident">WRITE_PROTECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.WRONG_FIRMWARE"><code class="name">var <span class="ident">WRONG_FIRMWARE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.FeigError.WRONG_TRANSPONDER_TYPE"><code class="name">var <span class="ident">WRONG_TRANSPONDER_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="itekfeig.HyWear"><code class="flex name class">
<span>class <span class="ident">HyWear</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all readers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyWear(FeigBase):
    # Reader Type, use this to match after connection
    READER_NAME = &#34;HYWEAR&#34;
    READER_TYPE = FEIG_READER_IDS[READER_NAME]

    INTERFACE_SERIAL = 0
    INTERFACE_ETHERNET = 1

    MODE_HOST = 0x00
    MODE_NOTIFICATION = 0xC0

    ANTENNA_OFF = 0
    ANTENNA_ON = 1

    POWER_LOW = 0
    POWER_MEDIUM = 1
    POWER_FULL = 2

    LED_GREEN = 1
    LED_RED = 2
    LED_BLUE = 3
    LED_YELLOW = 4

    def __init__(self):
        super().__init__()

        self._reader_info = {}
        self._device_id = None
        self._callback = None

        self._event = threading.Event()
        self._thread = None

    ####################################################################################
    ####    READER CONNECTION API
    ####################################################################################

    def connect(self, interface, settings) -&gt; bool:
        &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
        Onece the connection is established, a complete aconfiguration is read
        from the reader.

        Args:
            interface: one of the supported interface
            settings: of selected interface

        Returns:
            bool: True if connection is sccessfull

        Raises:
            ValueError for incorrect data
        &#34;&#34;&#34;
        if interface == self.INTERFACE_SERIAL:
            from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
            from ..interface.feig_serial import FeigSerial

            if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
                parity = PARITY_NONE
            elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
                parity = PARITY_EVEN
            elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
                parity = PARITY_ODD
            else:
                raise ValueError(&#34;NotSupported:Parity&#34;)

            FeigBase._interface = FeigSerial()
            opened = FeigBase._interface.open(
                settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity
            )
            if opened is False:
                FeigBase._last_error = FeigError.SERIAL
                err_msg = &#34;Failed to connect to {} {}&#34;.format(
                    settings[&#34;PORT&#34;], FeigBase._interface.error
                )
                logger.error(err_msg)
                return False

        elif interface == self.INTERFACE_ETHERNET:
            from ..interface.feig_ethernet import FeigEthernet

            FeigBase._interface = FeigEthernet()
            opened = FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])
            if opened is False:
                FeigBase._last_error = FeigError.ETHERNET
                return False

        else:
            raise ValueError(&#34;NotSupported:Interface&#34;)

        if FeigBase._interface._error is not None:
            FeigBase._last_error = FeigBase._interface._error
            return False

        # Forced: Antenna OFF, if tags are present in the feild
        # connection to reader takes time or fail
        self.rf_onoff(self.ANTENNA_OFF)

        time.sleep(0.1)

        # Get reader type
        ret = self._get_reader_type()
        if not ret:
            logger.error(&#34;Failed to get reader ID&#34;)
            return False

        if ret != self.READER_TYPE:
            FeigBase._last_error = FeigError.INVALID_READER
            FeigBase._interface.close()
            FeigBase._interface = None
            err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
            logger.error(err_msg)
            return False

        # Get ALL INFO from the reader
        self.get_reader_info()

        time.sleep(0.1)

        # Get ALL CONFIGURATION from reader memory
        ret = self.read_all_config()
        if ret is None:
            return False

        time.sleep(0.1)

        # Configure operating modes
        from ..common.feig_host import FeigHost
        self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error) # pylint: disable=C0103

        from ..common.feig_notification import FeigNotification
        self.NotificationMode = FeigNotification(FeigBase._interface, FeigBase._last_error) # pylint: disable=C0103

        return True

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
        if FeigBase._interface:
            FeigBase._interface.close()

    def rf_onoff(self, onoff: bool, maintainhost=False):
        &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;

        if onoff is True:
            rf_output = 0x01
        else:
            rf_output = 0x00

        if maintainhost is True:
            rf_output += 0x80

        cmd = [0x6A, rf_output]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6A:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        return False

    def _set_output_record_parser(self, out_rec: dict):
        out_nr = 0
        if out_rec[&#34;type&#34;] == &#34;led&#34;:
            out_nr = 0x20 + out_rec[&#34;pin&#34;]
        elif out_rec[&#34;type&#34;] == &#34;buzzer&#34;:
            out_nr = 0x40 + 1
        elif out_rec[&#34;type&#34;] == &#34;vibration&#34;:
            out_nr = 0x60 + 1
        elif out_rec[&#34;type&#34;] == &#34;trigger&#34;:
            out_nr = 0xE0 + 1
        else:
            raise ValueError(&#34;Invalid output type&#34;)

        out_s = 0
        if out_rec[&#34;mode&#34;] == &#34;flash&#34;:
            out_s = 3
            if out_rec[&#34;freq&#34;] == 1:
                out_s += 3 &lt;&lt; 2
            elif out_rec[&#34;freq&#34;] == 2:
                out_s += 2 &lt;&lt; 2
            elif out_rec[&#34;freq&#34;] == 4:
                out_s += 1 &lt;&lt; 2
            elif out_rec[&#34;freq&#34;] == 8:
                out_s += 0 &lt;&lt; 2
            else:
                raise ValueError(&#34;Invalid output flash frequency&#34;)
        elif out_rec[&#34;mode&#34;] == &#34;on&#34;:
            out_s = 1
        elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
            out_s = 2
        elif out_rec[&#34;mode&#34;] == &#34;unchange&#34;:
            out_s = 0
        else:
            raise ValueError(&#34;Invalid output mode&#34;)

        if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65534:
            raise ValueError(&#34;Invalid output time&#34;)
        out_time = out_rec[&#34;time&#34;]

        return out_nr, out_s, out_time

    def set_output(self, output=None, skipRx=False):
        &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

        Args:
            out_rec: key,value as per following format
                {
                    &#39;type&#39;: str, &#39;led&#39;, &#39;vibration&#39;, &#39;buzzer&#39;, &#39;trigger&#39;
                    &#39;pin&#39;: int,
                    &#39;mode&#39;: &#39;on&#39;, &#39;off&#39;, &#39;flash&#39;, &#39;unchange&#39;
                    &#39;freq&#39;: int, 1,2,4,8 Hz
                    &#39;time&#39;: int, 1 to 65534 delay corresponds to multiple of 100milli
                }
        &#34;&#34;&#34;
        if output is None:
            cmd = [0x72, 0x01, 0x00]

        elif isinstance(output, dict):
            out_nr, out_s, out_time = self._set_output_record_parser(output)
            cmd = [
                0x72,
                0x01,
                0x01,
                out_nr,
                out_s,
                (out_time &gt;&gt; 8) &amp; 0xFF,
                (out_time &gt;&gt; 0) &amp; 0xFF,
            ]

        elif isinstance(output, list):
            out_n = len(output)
            cmd = [
                0x72,
                0x01,
                out_n,
            ]
            for rec in output:
                out_nr, out_s, out_time = self._set_output_record_parser(rec)
                cmd.append(out_nr)
                cmd.append(out_s)
                cmd.append((out_time &gt;&gt; 8) &amp; 0xFF)
                cmd.append((out_time &gt;&gt; 0) &amp; 0xFF)
        else:
            raise TypeError(&#34;Invalid output record type&#34;)

        if skipRx is True:
            FeigBase._interface.write(cmd)
            return True

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x72:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

    def adjust_scanmode(self, idd: bool, button: bool, scanner_id: bool) -&gt; bool:
        &#34;&#34;&#34;Set scanmode data

        Args:
            idd: bool, True if transponder data is required
            button: bool, True if input button data is required
            scanner_id: bool, True if barcode data is required
        &#34;&#34;&#34;
        tr_data1 = 0x00

        cmd = [0x2A, 0x00, 0x00, 0x00]
        if idd: tr_data1 += 0x01

        if button or scanner_id:  #
            tr_data1 += 0x80
            cmd.append(tr_data1)

            tr_data2 = 0
            if button: tr_data2 += 0x01
            if scanner_id: tr_data2 += 0x04

            cmd.append(tr_data2)

        else:
            cmd.append(tr_data1)

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return False

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x2A:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        return False

    def configuration_parser(self, cfg_data: list):
        &#34;&#34;&#34;
        Parse configuration data.
        .. TODO::
        &#34;&#34;&#34;
        return True

    def _reader_info_parser(self, mode, data):
        if mode == 0x00:
            self._reader_info[&#34;RFControllerSoftwareRevision&#34;] = hexlify(
                data[0:3]
            ).decode(&#34;ascii&#34;)
            self._reader_info[&#34;HardwareType&#34;] = hexlify(data[3:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;ReaderType&#34;] = int(data[4])
            self._reader_info[&#34;TransponderTypes&#34;] = hexlify(data[5:7]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;MaxRXBufferSize&#34;] = data[7] * 256 + data[8]
            self._reader_info[&#34;MaxTXBufferSize&#34;] = data[9] * 256 + data[10]

        elif mode == 0x03:
            pass

        elif mode == 0x05:
            pass

        elif mode == 0x09:
            pass

        elif mode == 0x0B:
            pass

        elif mode == 0x10:
            internal_use = (
                hexlify(data[0:2]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[2:4]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[4:6]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;InternalUse&#34;] = internal_use

            freq = &#34;&#34;
            if data[6] &amp; 0x80:
                freq += &#34;HF,&#34;
            if data[6] &amp; 0x40:
                freq += &#34;UHF,&#34;
            if data[6] &amp; 0x04:
                freq += &#34;LOCK,&#34;
            else:
                freq += &#34;UNLOCK,&#34;
            if data[6] &amp; 0x02:
                freq += &#34;FCC,&#34;
            if data[6] &amp; 0x01:
                freq += &#34;EU&#34;
            self._reader_info[&#34;Frequency&#34;] = freq

            prt = &#34;&#34;
            if data[7] &amp; 0x01:
                prt += &#34;SERIAL,&#34;
            if data[7] &amp; 0x02:
                prt += &#34;RS485,&#34;
            if data[7] &amp; 0x04:
                prt += &#34;LAN,&#34;
            if data[7] &amp; 0x08:
                prt += &#34;WLAN,&#34;
            if data[7] &amp; 0x10:
                prt += &#34;USB,&#34;
            if data[7] &amp; 0x20:
                prt += &#34;BT,&#34;
            if data[7] &amp; 0x80:
                prt += &#34;DISCOVERY&#34;
            self._reader_info[&#34;SupportedPorts&#34;] = prt

        elif mode == 0x15:
            self._reader_info[&#34;RFStackSoftwareRevision&#34;] = hexlify(data[0:2]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x16:
            # TODO
            pass

        elif mode == 0x40:
            self._reader_info[&#34;ReadPages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;ReadPermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x41:
            self._reader_info[&#34;WritePages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;WritePermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x50:
            mac = (
                hexlify(data[1:2]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[2:3]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[3:4]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[4:5]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[5:6]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[6:7]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;MACAddress&#34;] = mac

            if data[7] &amp; 0x01:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;Off&#34;
            else:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;On&#34;

            if data[7] &amp; 0x02:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Full Duplex&#34;
            else:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Half Duplex&#34;

            if data[7] &amp; 0x04:
                self._reader_info[&#34;Speed&#34;] = &#34;100 Mbit&#34;
            else:
                self._reader_info[&#34;Speed&#34;] = &#34;10 Mbit&#34;

        elif mode == 0x51:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                ip = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Address&#34;] = ip
            else:
                self._reader_info[&#34;IPv4Address&#34;] = &#34;NA&#34;

        elif mode == 0x52:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                nm = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Netmask&#34;] = nm
            else:
                self._reader_info[&#34;IPv4Netmask&#34;] = &#34;NA&#34;

        elif mode == 0x53:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                gw = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Gateway&#34;] = gw
            else:
                self._reader_info[&#34;IPv4Gateway&#34;] = &#34;NA&#34;

        elif mode == 0x54:
            pass

        elif mode == 0x55:
            pass

        elif mode == 0x56:
            pass

        elif mode == 0x57:
            pass

        elif mode == 0x60:
            self._reader_info[&#34;Inputs&#34;] = data[0]
            self._reader_info[&#34;Outputs&#34;] = data[1]
            self._reader_info[&#34;Relays&#34;] = data[2]

        elif mode == 0x80:
            self._reader_info[&#34;DeviceID&#34;] = hexlify(data[0:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;CustomerID&#34;] = hexlify(data[4:8]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;FirmwareVersion&#34;] = hexlify(data[8:10]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;TransponderDriver&#34;] = hexlify(data[10:12]).decode(
                &#34;ascii&#34;
            )
            self._reader_info[&#34;FirmwareFunctions&#34;] = hexlify(data[12:14]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x81:
            # device info2
            pass

    def get_reader_info(self):
        &#34;&#34;&#34;Get complete reader information
        &#34;&#34;&#34;
        if len(self._reader_info) == 0:

            for mode in READER_INFO_MODE_LIST:
                cmd = [0x66, mode]
                data = FeigBase._interface.transfer(1.0, cmd)
                if data is None:
                    FeigBase._last_error = FeigError.COMM_TIMEOUT
                    return

                FeigBase._last_error = FeigError.INVALID_RESPONSE
                if data[0] == 0x66:
                    FeigBase._last_error = self._feig_status_parser(data[1])
                    if FeigBase._last_error is FeigError.OK:
                        self._reader_info_parser(mode, data[2:])

        return deepcopy(self._reader_info)

    @staticmethod
    def _diagnostic_parser(data):

        def test_error(x) -&gt; str:
            if x: return &#34;FAIL&#34;
            return &#34;OK&#34;

        diag = {}
        data_set = data[0]
        offset = 1
        for _ in range(0, data_set):
            mode = data[offset]
            if mode == 0x04:
                flagA = data[offset + 1]
                flagB = data[offset + 2]

                hwerr = {}
                hwerr[&#34;TriggerLocked&#34;] = test_error(flagA &amp; 0x02)
                hwerr[&#34;Barcode&#34;] = test_error(flagA &amp; 0x04)
                hwerr[&#34;WiFi_Bluetooth&#34;] = test_error(flagA &amp; 0x08)
                hwerr[&#34;Battery&#34;] = test_error(flagA &amp; 0x20)

                hwerr[&#34;RFDecoder&#34;] = test_error(flagB &amp; 0x08)
                hwerr[&#34;EEPROM&#34;] = test_error(flagB &amp; 0x01)

                diag[&#34;HardwareError&#34;] = hwerr

            elif mode == 0x10:
                voltage = data[offset + 1] * 256 + data[offset + 2]
                diag[&#34;Battery&#34;] = str(voltage) + &#34;mV&#34;

            elif mode == 0x20:
                # FIRMWARE
                diag[&#34;Firmware&#34;] = data[offset + 1 :].rstrip(b&#34;\x00&#34;).decode(&#34;ascii&#34;)

            offset = offset + 30 + 1

        return diag

    def diagnostic(self) -&gt; dict:
        &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6E:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return self._diagnostic_parser(data[2:])

    def device_id(self) -&gt; str:
        &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
        return deepcopy(self._reader_info[&#34;DeviceID&#34;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="itekfeig.HyWear.ANTENNA_OFF"><code class="name">var <span class="ident">ANTENNA_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.ANTENNA_ON"><code class="name">var <span class="ident">ANTENNA_ON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.INTERFACE_ETHERNET"><code class="name">var <span class="ident">INTERFACE_ETHERNET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.INTERFACE_SERIAL"><code class="name">var <span class="ident">INTERFACE_SERIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.LED_BLUE"><code class="name">var <span class="ident">LED_BLUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.LED_GREEN"><code class="name">var <span class="ident">LED_GREEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.LED_RED"><code class="name">var <span class="ident">LED_RED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.LED_YELLOW"><code class="name">var <span class="ident">LED_YELLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.MODE_HOST"><code class="name">var <span class="ident">MODE_HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.MODE_NOTIFICATION"><code class="name">var <span class="ident">MODE_NOTIFICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.POWER_FULL"><code class="name">var <span class="ident">POWER_FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.POWER_LOW"><code class="name">var <span class="ident">POWER_LOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.POWER_MEDIUM"><code class="name">var <span class="ident">POWER_MEDIUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.READER_NAME"><code class="name">var <span class="ident">READER_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.HyWear.READER_TYPE"><code class="name">var <span class="ident">READER_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="itekfeig.HyWear.adjust_scanmode"><code class="name flex">
<span>def <span class="ident">adjust_scanmode</span></span>(<span>self, idd:Â bool, button:Â bool, scanner_id:Â bool) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Set scanmode data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>idd</code></strong></dt>
<dd>bool, True if transponder data is required</dd>
<dt><strong><code>button</code></strong></dt>
<dd>bool, True if input button data is required</dd>
<dt><strong><code>scanner_id</code></strong></dt>
<dd>bool, True if barcode data is required</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_scanmode(self, idd: bool, button: bool, scanner_id: bool) -&gt; bool:
    &#34;&#34;&#34;Set scanmode data

    Args:
        idd: bool, True if transponder data is required
        button: bool, True if input button data is required
        scanner_id: bool, True if barcode data is required
    &#34;&#34;&#34;
    tr_data1 = 0x00

    cmd = [0x2A, 0x00, 0x00, 0x00]
    if idd: tr_data1 += 0x01

    if button or scanner_id:  #
        tr_data1 += 0x80
        cmd.append(tr_data1)

        tr_data2 = 0
        if button: tr_data2 += 0x01
        if scanner_id: tr_data2 += 0x04

        cmd.append(tr_data2)

    else:
        cmd.append(tr_data1)

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return False

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x2A:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.configuration_parser"><code class="name flex">
<span>def <span class="ident">configuration_parser</span></span>(<span>self, cfg_data:Â list)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition todo">
<p class="admonition-title">TODO</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configuration_parser(self, cfg_data: list):
    &#34;&#34;&#34;
    Parse configuration data.
    .. TODO::
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, interface, settings) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the reader using one of its interface with given settings.
Onece the connection is established, a complete aconfiguration is read
from the reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong></dt>
<dd>one of the supported interface</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>of selected interface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection is sccessfull</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError for incorrect data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, interface, settings) -&gt; bool:
    &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
    Onece the connection is established, a complete aconfiguration is read
    from the reader.

    Args:
        interface: one of the supported interface
        settings: of selected interface

    Returns:
        bool: True if connection is sccessfull

    Raises:
        ValueError for incorrect data
    &#34;&#34;&#34;
    if interface == self.INTERFACE_SERIAL:
        from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
        from ..interface.feig_serial import FeigSerial

        if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
            parity = PARITY_NONE
        elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
            parity = PARITY_EVEN
        elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
            parity = PARITY_ODD
        else:
            raise ValueError(&#34;NotSupported:Parity&#34;)

        FeigBase._interface = FeigSerial()
        opened = FeigBase._interface.open(
            settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity
        )
        if opened is False:
            FeigBase._last_error = FeigError.SERIAL
            err_msg = &#34;Failed to connect to {} {}&#34;.format(
                settings[&#34;PORT&#34;], FeigBase._interface.error
            )
            logger.error(err_msg)
            return False

    elif interface == self.INTERFACE_ETHERNET:
        from ..interface.feig_ethernet import FeigEthernet

        FeigBase._interface = FeigEthernet()
        opened = FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])
        if opened is False:
            FeigBase._last_error = FeigError.ETHERNET
            return False

    else:
        raise ValueError(&#34;NotSupported:Interface&#34;)

    if FeigBase._interface._error is not None:
        FeigBase._last_error = FeigBase._interface._error
        return False

    # Forced: Antenna OFF, if tags are present in the feild
    # connection to reader takes time or fail
    self.rf_onoff(self.ANTENNA_OFF)

    time.sleep(0.1)

    # Get reader type
    ret = self._get_reader_type()
    if not ret:
        logger.error(&#34;Failed to get reader ID&#34;)
        return False

    if ret != self.READER_TYPE:
        FeigBase._last_error = FeigError.INVALID_READER
        FeigBase._interface.close()
        FeigBase._interface = None
        err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
        logger.error(err_msg)
        return False

    # Get ALL INFO from the reader
    self.get_reader_info()

    time.sleep(0.1)

    # Get ALL CONFIGURATION from reader memory
    ret = self.read_all_config()
    if ret is None:
        return False

    time.sleep(0.1)

    # Configure operating modes
    from ..common.feig_host import FeigHost
    self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error) # pylint: disable=C0103

    from ..common.feig_notification import FeigNotification
    self.NotificationMode = FeigNotification(FeigBase._interface, FeigBase._last_error) # pylint: disable=C0103

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.device_id"><code class="name flex">
<span>def <span class="ident">device_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns reader device ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_id(self) -&gt; str:
    &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
    return deepcopy(self._reader_info[&#34;DeviceID&#34;])</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.diagnostic"><code class="name flex">
<span>def <span class="ident">diagnostic</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Perform reader diagnostic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostic(self) -&gt; dict:
    &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6E:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return self._diagnostic_parser(data[2:])</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from current reader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
    if FeigBase._interface:
        FeigBase._interface.close()</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.get_reader_info"><code class="name flex">
<span>def <span class="ident">get_reader_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get complete reader information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reader_info(self):
    &#34;&#34;&#34;Get complete reader information
    &#34;&#34;&#34;
    if len(self._reader_info) == 0:

        for mode in READER_INFO_MODE_LIST:
            cmd = [0x66, mode]
            data = FeigBase._interface.transfer(1.0, cmd)
            if data is None:
                FeigBase._last_error = FeigError.COMM_TIMEOUT
                return

            FeigBase._last_error = FeigError.INVALID_RESPONSE
            if data[0] == 0x66:
                FeigBase._last_error = self._feig_status_parser(data[1])
                if FeigBase._last_error is FeigError.OK:
                    self._reader_info_parser(mode, data[2:])

    return deepcopy(self._reader_info)</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.rf_onoff"><code class="name flex">
<span>def <span class="ident">rf_onoff</span></span>(<span>self, onoff:Â bool, maintainhost=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn ON/OFF individual antenna</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rf_onoff(self, onoff: bool, maintainhost=False):
    &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;

    if onoff is True:
        rf_output = 0x01
    else:
        rf_output = 0x00

    if maintainhost is True:
        rf_output += 0x80

    cmd = [0x6A, rf_output]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6A:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.HyWear.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, output=None, skipRx=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set/Configure Digital Output or Relay pins</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>out_rec</code></strong></dt>
<dd>key,value as per following format
{
'type': str, 'led', 'vibration', 'buzzer', 'trigger'
'pin': int,
'mode': 'on', 'off', 'flash', 'unchange'
'freq': int, 1,2,4,8 Hz
'time': int, 1 to 65534 delay corresponds to multiple of 100milli
}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, output=None, skipRx=False):
    &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

    Args:
        out_rec: key,value as per following format
            {
                &#39;type&#39;: str, &#39;led&#39;, &#39;vibration&#39;, &#39;buzzer&#39;, &#39;trigger&#39;
                &#39;pin&#39;: int,
                &#39;mode&#39;: &#39;on&#39;, &#39;off&#39;, &#39;flash&#39;, &#39;unchange&#39;
                &#39;freq&#39;: int, 1,2,4,8 Hz
                &#39;time&#39;: int, 1 to 65534 delay corresponds to multiple of 100milli
            }
    &#34;&#34;&#34;
    if output is None:
        cmd = [0x72, 0x01, 0x00]

    elif isinstance(output, dict):
        out_nr, out_s, out_time = self._set_output_record_parser(output)
        cmd = [
            0x72,
            0x01,
            0x01,
            out_nr,
            out_s,
            (out_time &gt;&gt; 8) &amp; 0xFF,
            (out_time &gt;&gt; 0) &amp; 0xFF,
        ]

    elif isinstance(output, list):
        out_n = len(output)
        cmd = [
            0x72,
            0x01,
            out_n,
        ]
        for rec in output:
            out_nr, out_s, out_time = self._set_output_record_parser(rec)
            cmd.append(out_nr)
            cmd.append(out_s)
            cmd.append((out_time &gt;&gt; 8) &amp; 0xFF)
            cmd.append((out_time &gt;&gt; 0) &amp; 0xFF)
    else:
        raise TypeError(&#34;Invalid output record type&#34;)

    if skipRx is True:
        FeigBase._interface.write(cmd)
        return True

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x72:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></b></code>:
<ul class="hlist">
<li><code><a title="itekfeig.common.feig_base.FeigBase.add_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.add_filter">add_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error">get_last_error</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error_str" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error_str">get_last_error_str</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_software_version" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_software_version">get_software_version</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.login" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.login">login</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_all_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_all_config">read_all_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_config">read_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.remove_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.remove_filter">remove_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.reset_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.reset_config">reset_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_controller_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_controller_reset">rf_controller_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_reset">rf_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.system_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.system_reset">system_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.write_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.write_config">write_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="itekfeig.LRU1002"><code class="flex name class">
<span>class <span class="ident">LRU1002</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all readers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LRU1002(FeigBase):
    # Reader Type, use this to match after connection
    READER_NAME = &#34;LRU1002&#34;
    READER_TYPE = FEIG_READER_IDS[READER_NAME]

    INTERFACE_SERIAL = 0
    INTERFACE_ETHERNET = 1

    MODE_HOST = 0x00
    MODE_SCAN = 0x01
    MODE_BRM = 0x80
    MODE_NOTIFICATION = 0xC0

    ANTENNA_OFF = 0x00

    ANTENNA_No1 = 0x01
    ANTENNA_No2 = 0x02
    ANTENNA_No3 = 0x03
    ANTENNA_No4 = 0x04

    MAX_ANTENNA = 4

    # in milliwatts
    POWER_LOW = 100
    POWER_MEDIUM = 1000
    POWER_FULL = 2000

    RSSI_MIN = 0  # disabled
    RSSI_MAX = 255

    def __init__(self):
        super().__init__()

        self._reader_info = {}
        self._deviceId = None

    ####################################################################################
    ####    READER CONNECTION API
    ####################################################################################

    def connect(self, interface, settings):
        &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
        Onece the connection is established, a complete aconfiguration is read
        from the reader.

        Args:
            interface: one of the supported interface
            settings: of selected interface

        Returns:
            bool: True if connection is sccessfull
        &#34;&#34;&#34;
        if interface == self.INTERFACE_SERIAL:
            from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
            from ..interface.feig_serial import FeigSerial

            if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
                parity = PARITY_NONE
            elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
                parity = PARITY_EVEN
            elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
                parity = PARITY_ODD
            else:
                raise ValueError(&#34;NotSupported:Parity&#34;)

            FeigBase._interface = FeigSerial()
            FeigBase._interface.open(settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity)

        elif interface == self.INTERFACE_ETHERNET:
            from ..interface.feig_ethernet import FeigEthernet

            FeigBase._interface = FeigEthernet()
            FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])

        else:
            raise ValueError(&#34;NotSupported:Interface&#34;)

        if FeigBase._interface.error != FeigError.OK:
            FeigBase._last_error = FeigBase._interface.error
            return False

        # Forced: Antenna OFF, if tags are present in the feild
        # connection to reader takes time or fail
        self.rf_onoff(self.ANTENNA_OFF)

        time.sleep(0.1)

        # Get reader type
        ret = self._get_reader_type()
        if not ret:
            logger.error(&#34;Failed to get reader ID&#34;)
            return False

        if ret != self.READER_TYPE:
            FeigBase._last_error = FeigError.INVALID_READER
            FeigBase._interface.close()
            FeigBase._interface = None
            err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
            logger.error(err_msg)
            return False

        # Get ALL INFO from the reader
        self.get_reader_info()

        time.sleep(0.1)

        # Get ALL CONFIGURATION from reader memory
        ret = self.read_all_config()
        if ret is None:
            return False

        time.sleep(0.1)

        # Configure operating modes
        from ..common.feig_host import FeigHost
        self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

        from ..common.feig_buffer_read import FeigBufferRead
        self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

        if interface == self.INTERFACE_SERIAL:
            from ..common.feig_scan import FeigScan
            self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)

        elif interface == self.INTERFACE_ETHERNET:
            from ..common.feig_notification import FeigNotification
            self.NotificationMode = FeigNotification(
                FeigBase._interface, FeigBase._last_error
            )

        return True

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
        if FeigBase._interface:
            FeigBase._interface.close()

    ####################################################################################
    ####    READER CONTROL API
    ####################################################################################

    def rf_onoff(self, antno, maintainhost=False):
        &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
        rf_output = 0
        if maintainhost is True:
            rf_output += 0x80
        rf_output += antno

        cmd = [0x6A, rf_output]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6A:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        return False

    def set_output(self, out_rec: dict):
        &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

        Args:
            out_rec: key,value as per following format
                {
                    &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                    &#39;pin&#39;: int,
                    &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                    &#39;freq&#39;: int, 1,2,4,8 Hz
                    &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
                }
        &#34;&#34;&#34;
        if out_rec[&#34;type&#34;] == &#34;digital&#34;:
            out_type = 0x00
        elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
            out_type = 0x80
        else:
            raise ValueError(&#34;Invalid Value&#34;)
        out_type = 0x80 + out_rec[&#34;pin&#34;]

        if out_rec[&#34;mode&#34;] == &#34;on&#34;:
            out_state = 0x01
        elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
            out_state = 0x02
        elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
            out_state = 0x03
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;freq&#34;] == 1:
            out_state += 0x03 * 4
        elif out_rec[&#34;freq&#34;] == 2:
            out_state += 0x02 * 4
        elif out_rec[&#34;freq&#34;] == 4:
            out_state += 0x01 * 4
        elif out_rec[&#34;freq&#34;] == 8:
            out_state += 0x00 * 4
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
            raise ValueError(&#34;Invalid Value&#34;)
        out_time = out_rec[&#34;time&#34;]

        cmd = [
            0x72,
            0x01,
            0x01,
            out_type,
            out_state,
            (out_time &gt;&gt; 8) &amp; 0xFF,
            (out_time &gt;&gt; 0) &amp; 0xFF,
        ]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x72:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

    def get_input(self):
        &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x74:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                in1 = data[2] &amp; 0x01
                in2 = (data[2] &gt;&gt; 1) &amp; 0x01
                return in1, in2

    def change_mode(self, mode):
        &#34;&#34;&#34;Change Reader mode

        Args:
            mode: one of the supporeted operating mode

        Returns:
            None: Call get_last_error() for more reason
            bool: If True, new mode is set in the reader
        &#34;&#34;&#34;
        cfgData = self.read_config(1)
        if cfgData is None:
            return False

        if cfgData[13] == mode:  # Current Mode is same
            FeigBase._last_error = FeigError.MODE_SAME
            return False

        # update mode
        cfgData[13] = mode

        ret = self.write_config(1, cfgData)
        if ret is None:
            return False

        FeigBase._current_mode = mode

        return True

    @staticmethod
    def _diagnostic_parser(data):

        def test_error(x):
            if x: return &#34;FAIL&#34;
            return &#34;OK&#34;

        diag = {}
        data_set = data[0]
        offset = 1
        for _ in range(0, data_set):
            mode = data[offset]
            if mode == 0x01:
                flag_a = data[offset + 1]
                flag_b = data[offset + 2]

                rf_status = {}
                rf_status[&#34;NOISE&#34;] = test_error(flag_a &amp; 0x02)
                rf_status[&#34;POWER&#34;] = test_error(flag_a &amp; 0x10)
                rf_status[&#34;TEMP_WARNING&#34;] = test_error(flag_a &amp; 0x20)
                rf_status[&#34;TEMP_ALARM&#34;] = test_error(flag_a &amp; 0x80)

                # ANTENNA FLAGS are SET when impedance |Z| != 50
                rf_status[&#34;Antenna1&#34;] = test_error(flag_b &amp; 0x01)
                rf_status[&#34;Antenna2&#34;] = test_error(flag_b &amp; 0x02)
                rf_status[&#34;Antenna3&#34;] = test_error(flag_b &amp; 0x04)
                rf_status[&#34;Antenna4&#34;] = test_error(flag_b &amp; 0x08)

                diag[&#34;RF_Status&#34;] = rf_status

            elif mode == 0x04:
                # EEPROM
                eeprom = {}
                int_error = data[offset + 1] * 256 + data[offset + 2]

                eeprom[&#34;EE_DEV1&#34;] = test_error(int_error &amp; 0x0001)
                eeprom[&#34;RF_DECODER&#34;] = test_error(int_error &amp; 0x0004)
                eeprom[&#34;RTC&#34;] = test_error(int_error &amp; 0x0040)
                eeprom[&#34;ADC&#34;] = test_error(int_error &amp; 0x0080)
                eeprom[&#34;IO_EXPANDER&#34;] = test_error(int_error &amp; 0x0100)
                eeprom[&#34;DC_OUT&#34;] = test_error(int_error &amp; 0x0200)
                eeprom[&#34;USB_IMAX&#34;] = test_error(int_error &amp; 0x0400)

                diag[&#34;Eeprom&#34;] = eeprom

            elif mode == 0x05:
                # MUX
                diag[&#34;Mux1&#34;] = hex(data[offset + 1])
                diag[&#34;Mux2&#34;] = hex(data[offset + 4])
                diag[&#34;Mux3&#34;] = hex(data[offset + 7])
                diag[&#34;Mux4&#34;] = hex(data[offset + 10])

            elif mode == 0x20:
                # FIRMWARE
                diag[&#34;Firmware&#34;] = data[offset + 1 :].rstrip(b&#34;\x00&#34;).decode(&#34;ascii&#34;)

            offset = offset + 30 + 1

        return diag

    def diagnostic(self):
        &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6E:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return self._diagnostic_parser(data[2:])

    ####################################################################################
    ####    READER INFO API
    ####################################################################################
    def _reader_info_parser(self, mode, data):
        if mode == 0x00:
            self._reader_info[&#34;RFControllerSoftwareRevision&#34;] = hexlify(
                data[0:3]
            ).decode(&#34;ascii&#34;)
            self._reader_info[&#34;HardwareType&#34;] = hexlify(data[3:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;ReaderType&#34;] = int(data[4])
            self._reader_info[&#34;TransponderTypes&#34;] = hexlify(data[5:7]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;MaxRXBufferSize&#34;] = data[7] * 256 + data[8]
            self._reader_info[&#34;MaxTXBufferSize&#34;] = data[9] * 256 + data[10]

        elif mode == 0x10:
            internal_use = (
                hexlify(data[0:2]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[2:4]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[4:6]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;InternalUse&#34;] = internal_use

            freq = &#34;&#34;
            if data[6] &amp; 0x80:
                freq += &#34;HF,&#34;
            if data[6] &amp; 0x40:
                freq += &#34;UHF,&#34;
            if data[6] &amp; 0x04:
                freq += &#34;LOCK,&#34;
            else:
                freq += &#34;UNLOCK,&#34;
            if data[6] &amp; 0x02:
                freq += &#34;FCC,&#34;
            if data[6] &amp; 0x01:
                freq += &#34;EU&#34;
            self._reader_info[&#34;Frequency&#34;] = freq

            prt = &#34;&#34;
            if data[7] &amp; 0x01:
                prt += &#34;SERIAL,&#34;
            if data[7] &amp; 0x02:
                prt += &#34;RS485,&#34;
            if data[7] &amp; 0x04:
                prt += &#34;LAN,&#34;
            if data[7] &amp; 0x08:
                prt += &#34;WLAN,&#34;
            if data[7] &amp; 0x10:
                prt += &#34;USB,&#34;
            if data[7] &amp; 0x20:
                prt += &#34;BT,&#34;
            if data[7] &amp; 0x80:
                prt += &#34;DISCOVERY&#34;
            self._reader_info[&#34;SupportedPorts&#34;] = prt

        elif mode == 0x15:
            self._reader_info[&#34;RFStackSoftwareRevision&#34;] = hexlify(data[0:2]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x16:
            # .. TODO::
            pass

        elif mode == 0x40:
            self._reader_info[&#34;ReadPages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;ReadPermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x41:
            self._reader_info[&#34;WritePages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;WritePermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x50:
            mac = (
                hexlify(data[1:2]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[2:3]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[3:4]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[4:5]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[5:6]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[6:7]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;MACAddress&#34;] = mac

            if data[7] &amp; 0x01:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;Off&#34;
            else:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;On&#34;

            if data[7] &amp; 0x02:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Full Duplex&#34;
            else:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Half Duplex&#34;

            if data[7] &amp; 0x04:
                self._reader_info[&#34;Speed&#34;] = &#34;100 Mbit&#34;
            else:
                self._reader_info[&#34;Speed&#34;] = &#34;10 Mbit&#34;

        elif mode == 0x51:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                ip = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Address&#34;] = ip
            else:
                self._reader_info[&#34;IPv4Address&#34;] = &#34;NA&#34;

        elif mode == 0x52:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                nm = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Netmask&#34;] = nm
            else:
                self._reader_info[&#34;IPv4Netmask&#34;] = &#34;NA&#34;

        elif mode == 0x53:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                gw = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Gateway&#34;] = gw
            else:
                self._reader_info[&#34;IPv4Gateway&#34;] = &#34;NA&#34;

        elif mode == 0x60:
            self._reader_info[&#34;Inputs&#34;] = data[0]
            self._reader_info[&#34;Outputs&#34;] = data[1]
            self._reader_info[&#34;Relays&#34;] = data[2]

        elif mode == 0x80:
            self._reader_info[&#34;DeviceID&#34;] = hexlify(data[0:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;CustomerID&#34;] = hexlify(data[4:8]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;FirmwareVersion&#34;] = hexlify(data[8:10]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;TransponderDriver&#34;] = hexlify(data[10:12]).decode(
                &#34;ascii&#34;
            )
            self._reader_info[&#34;FirmwareFunctions&#34;] = hexlify(data[12:14]).decode(
                &#34;ascii&#34;
            )

    def get_reader_info(self):
        &#34;&#34;&#34;Get complete reader information
        &#34;&#34;&#34;
        if len(self._reader_info) == 0:

            for mode in READER_INFO_MODE_LIST:
                cmd = [0x66, mode]
                data = FeigBase._interface.transfer(1.0, cmd)
                if data is None:
                    FeigBase._last_error = FeigError.COMM_TIMEOUT
                    return

                FeigBase._last_error = FeigError.INVALID_RESPONSE
                if data[0] == 0x66:
                    FeigBase._last_error = self._feig_status_parser(data[1])
                    if FeigBase._last_error is FeigError.OK:
                        self._reader_info_parser(mode, data[2:])

        return deepcopy(self._reader_info)

    def device_id(self) -&gt; str:
        &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
        return deepcopy(self._reader_info[&#34;DeviceID&#34;])

    ##########################################################################
    ####    READER CONFIGURATION API
    ##########################################################################

    def antenna_power(self, ant, pwr_in_milliwatts: int = -1) -&gt; Union[bool, int]:
        &#34;&#34;&#34;Change Antenna Power

        Args:
            ant: must be one of supported ANTENNA_No*
            pwr_in_milliwatts: int, in milliwats
            if -1 return current power

        Returns:
            bool: True, if power is set in the reader
            pwr_in_milliwatts: int

        Raises:
            ValueError

        .. note:: Given power is always adjusted to nearest valid value.
        &#34;&#34;&#34;
        if not (
            ant is self.ANTENNA_No1
            or ant is self.ANTENNA_No2
            or ant is self.ANTENNA_No3
            or ant is self.ANTENNA_No4
        ):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        # depending upon antenna read config
        if ant is self.ANTENNA_No1:
            cfg_page = 3
        else:
            cfg_page = 20

        # Get index of respective antenna
        index = 2  # Default to Antenna1
        if ant is self.ANTENNA_No2:
            index = 10
        elif ant is self.ANTENNA_No3:
            index = 11
        elif ant is self.ANTENNA_No4:
            index = 12

        # read current configuration
        cfgData = self.read_config(cfg_page)
        if cfgData is None:
            return False

        if pwr_in_milliwatts == -1:
            return ANTENNA_POWER[cfgData[index]]

        # check antenna power
        # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
        if pwr_in_milliwatts &lt; 200:
            pwr = ANTENNA_POWER_REVERSE[100]
        elif 200 &lt;= pwr_in_milliwatts &lt; 300:
            pwr = ANTENNA_POWER_REVERSE[200]
        elif 300 &lt;= pwr_in_milliwatts &lt; 400:
            pwr = ANTENNA_POWER_REVERSE[300]
        elif 400 &lt;= pwr_in_milliwatts &lt; 500:
            pwr = ANTENNA_POWER_REVERSE[400]
        elif 500 &lt;= pwr_in_milliwatts &lt; 600:
            pwr = ANTENNA_POWER_REVERSE[500]
        elif 600 &lt;= pwr_in_milliwatts &lt; 700:
            pwr = ANTENNA_POWER_REVERSE[600]
        elif 700 &lt;= pwr_in_milliwatts &lt; 800:
            pwr = ANTENNA_POWER_REVERSE[700]
        elif 800 &lt;= pwr_in_milliwatts &lt; 900:
            pwr = ANTENNA_POWER_REVERSE[800]
        elif 900 &lt;= pwr_in_milliwatts &lt; 1000:
            pwr = ANTENNA_POWER_REVERSE[900]
        elif 1000 &lt;= pwr_in_milliwatts &lt; 1100:
            pwr = ANTENNA_POWER_REVERSE[1000]
        elif 1100 &lt;= pwr_in_milliwatts &lt; 1200:
            pwr = ANTENNA_POWER_REVERSE[1100]
        elif 1200 &lt;= pwr_in_milliwatts &lt; 1300:
            pwr = ANTENNA_POWER_REVERSE[1200]
        elif 1300 &lt;= pwr_in_milliwatts &lt; 1400:
            pwr = ANTENNA_POWER_REVERSE[1300]
        elif 1400 &lt;= pwr_in_milliwatts &lt; 1500:
            pwr = ANTENNA_POWER_REVERSE[1400]
        elif 1500 &lt;= pwr_in_milliwatts &lt; 1600:
            pwr = ANTENNA_POWER_REVERSE[1500]
        elif 1600 &lt;= pwr_in_milliwatts &lt; 1700:
            pwr = ANTENNA_POWER_REVERSE[1600]
        elif 1700 &lt;= pwr_in_milliwatts &lt; 1800:
            pwr = ANTENNA_POWER_REVERSE[1700]
        elif 1800 &lt;= pwr_in_milliwatts &lt; 1900:
            pwr = ANTENNA_POWER_REVERSE[1800]
        elif 1900 &lt;= pwr_in_milliwatts &lt; 2000:
            pwr = ANTENNA_POWER_REVERSE[1900]
        else:  # pwr_in_milliwatts &gt;= 2000:
            pwr = ANTENNA_POWER_REVERSE[2000]

        cfgData[index] = pwr

        ret = self.write_config(cfg_page, cfgData)
        if ret is None:
            return False

        return True

    def antenna_rssi(self, ant: int, rssi: int):
        &#34;&#34;&#34;Change Antenna RSSI

        Args:
            ant: must be one of supported ANTENNA_No*
            rssi: must be in range RSSI_MIN and RSSI_MAX
            IF rssi == 0, then itis disabled

        Returns:
            bool: True, if power is set in the reader
            rssi: current rssi value

        Raises:
            ValueError
        &#34;&#34;&#34;
        if not (
            ant is self.ANTENNA_No1
            or ant is self.ANTENNA_No2
            or ant is self.ANTENNA_No3
            or ant is self.ANTENNA_No4
        ):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
            raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

        cfgData = self.read_config(20)
        if cfgData is None:
            return False

        # update rssi
        if ant is self.ANTENNA_No1:
            cfgData[0] = rssi

        elif ant is self.ANTENNA_No2:
            cfgData[1] = rssi

        elif ant is self.ANTENNA_No3:
            cfgData[2] = rssi

        elif ant is self.ANTENNA_No4:
            cfgData[3] = rssi

        ret = self.write_config(20, cfgData)
        if ret is None:
            return False

        return True

    def system_timer(self, timer_value=None):
        if timer_value is None:
            # get
            cmd = [0x86]
        else:
            # set
            if not isinstance(timer_value, tuple):
                raise ValueError(&#34;Invalid Argument&#34;)

            hour = timer_value[0]
            minutes = timer_value[1]
            milli = timer_value[2]
            if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
                raise ValueError(&#34;Invalid range&#34;)

            cmd = [0x85, hour, minutes, (milli &gt;&gt; 8) &amp; 0xFF, (milli &gt;&gt; 0) &amp; 0xFF]

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return False

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x85:  # Set
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        elif data[0] == 0x86:  # Get
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return data[2], data[3], (data[4] * 256 + data[5])

    def system_date_time(self, date_value=None, timer_value=None) -&gt; Union[bool, tuple]:
        if date_value is None and timer_value is None:
            # get
            cmd = [0x88]
        else:
            # set
            if not isinstance(date_value, tuple):
                raise ValueError(&#34;Invalid Argument {}&#34;.format(date_value))
            if not isinstance(timer_value, tuple):
                raise ValueError(&#34;Invalid Argument {}&#34;.format(timer_value))

            century = date_value[0]
            year = date_value[1]
            month = date_value[2]
            day = date_value[3]
            timezone = date_value[4]
            if (
                (century &gt; 99)
                or (year &gt; 99)
                or ((month &lt; 1) or (month &gt; 12))
                or ((day &lt; 1) or (day &gt; 31))
                or (timezone &gt; 23)
            ):
                raise ValueError(&#34;Invalid range&#34;)

            hour = timer_value[0]
            minutes = timer_value[1]
            milli = timer_value[2]
            if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
                raise ValueError(&#34;Invalid range&#34;)

            cmd = [
                0x87,
                century,
                year,
                month,
                day,
                timezone,
                hour,
                minutes,
                (milli &gt;&gt; 8) &amp; 0xFF,
                (milli &gt;&gt; 0) &amp; 0xFF,
            ]

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return False

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x87:  # Set
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        elif data[0] == 0x88:  # Get
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return (
                    (data[2], data[3], data[4], data[5], data[6]),
                    (data[7], data[8], (data[9] * 256 + data[10])),
                )

        return False

    def notification_channel(self, ackData=None, dstHost=None, keepAlive=None, holdTime=None)-&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure Notification channel of the reader

        Args:
            ackData:bool,
                True = Acknowledge Notification Data

            dstHost:tuple, (dstIP,dstPort)
                dstIP: str, Destination IPv4
                dstIP: str/int, Destination PORT from 0 - 65535

            keepAlive:tuple, (enable, time)
                enable: bool, True to enable keep alive message
                time: int, keep alive message time from 0 - 65535 secs

            holdTime:int, Defines the connection hold time from 0 - 255 sec

        Returns:
            currentConfig: dict, If no argument is passed return current config
                {
                    &#39;ackData&#39;: None,
                    &#39;dstHost&#39;: None,
                    &#39;keepAlive&#39;: None
                }

            status: bool, True if configuration set successfully
        &#34;&#34;&#34;

        # check argument
        if ackData and not isinstance(ackData, bool):
            raise TypeError(&#34;bool type expected&#34;)

        if dstHost and not isinstance(dstHost, tuple):
            raise TypeError(&#34;tuple type expected&#34;)

        if keepAlive and not isinstance(keepAlive, tuple):
            raise TypeError(&#34;tuple type expected&#34;)

        if holdTime and not isinstance(holdTime, int):
            raise TypeError(&#34;int type expected&#34;)

        cfgData = self.read_config(49)
        if cfgData is None:
            return False

        if not ackData and not dstHost and not keepAlive:
            # return dictionary
            ackData = bool(cfgData[0] &amp; 0x80)

            dstIp = (
                (cfgData[7] &lt;&lt; 24)
                + (cfgData[8] &lt;&lt; 16)
                + (cfgData[9] &lt;&lt; 8)
                + cfgData[10]
            )
            dstIp = str(ipaddress.ip_address(dstIp))
            dstPort = cfgData[11] * 256 + cfgData[12]

            keepen = bool(cfgData[4] &amp; 0x01)
            keeptime = cfgData[5] * 256 + cfgData[6]

            holdTime = cfgData[13]

            return {
                &#34;ackData&#34;: ackData,
                &#34;dstHost&#34;: (dstIp, dstPort),
                &#34;keepAlive&#34;: (keepen, keeptime),
                &#34;holdTime&#34;: holdTime,
            }

        # set ack
        if ackData:
            if ackData is True:
                cfgData[0] = 0x80
            else:
                cfgData[0] = 0x00

        # keep alive
        if keepAlive:
            if keepAlive[0] is True:
                cfgData[4] = 0x01
            else:
                cfgData[4] = 0x00
            if keepAlive[1] &gt; 65535:
                raise ValueError(&#34;keepAlive time exceeds range&#34;)
            cfgData[5] = (keepAlive[1] &gt;&gt; 8) &amp; 255
            cfgData[6] = (keepAlive[1] &gt;&gt; 0) &amp; 255

        # destintation
        if dstHost:
            try:
                ipaddr = dstHost[0]
                ipaddr = int(ipaddress.ip_address(ipaddr))
                ipaddr = ipaddress.v4_int_to_packed(ipaddr)
                iperr = False
            except ipaddress.AddressValueError:
                iperr = True
            if iperr is True:
                raise ValueError(&#34;dst IP incorrect&#34;)
            cfgData[7] = ipaddr[0]
            cfgData[8] = ipaddr[1]
            cfgData[9] = ipaddr[2]
            cfgData[10] = ipaddr[3]

            if dstHost[1] &gt; 65535:
                raise ValueError(&#34;dst Port excceds range&#34;)
            cfgData[11] = (dstHost[1] &gt;&gt; 8) &amp; 255
            cfgData[12] = (dstHost[1] &gt;&gt; 0) &amp; 255

        # hold time
        if holdTime:
            if holdTime &gt; 255:
                raise ValueError(&#34;holdTime exceeds range&#34;)
            cfgData[13] = holdTime

        # write configs
        ret = self.write_config(49, cfgData)
        if ret is None:
            return False

        return True

    def read_mode_data(self, flags=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure READ MODE data

        Args:
            flags: dict, All parameters are MANDATORY
            {
                &#39;uid&#39;: bool, If True reader will send IDD(EPC or EPC+TID)
                &#39;lsb&#39;: bool, If True byte order of frame will be LSB else MSB
                &#39;time&#39;: bool, If True reader will send its time
                &#39;date&#39;: bool, If True reader will send its date
                &#39;input&#39;: bool, If True reader will send its INPUT status
                &#39;mac&#39;: bool, If True reader will send its MAC address
                &#39;input&#39;: bool, If True reader will send its INPUT status

                &#39;antno&#39;: bool, If True reader will send Antenna number
                &#39;antext&#39;: bool, If True reader will send antenna rssi, phase angle
                &#39;antstore&#39;: bool, If True reader will collect transponder data from all antennas in one data record

                &#39;readall&#39;: bool, If True reader will read complete BANK data
                &#39;bank&#39;: int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

                &#39;db&#39;: bool, If True reader will send DATA BLOCKs
                &#39;dbaddr&#39;: int, Address of first data blocks from 0 to 65535
                &#39;dbn&#39;: int, Number of data blocks from 0 to 65535
            }

        Returns:
            flags: dict , If no argument is passed current settings is send as per above flags definitions
            True: If write opertaion is successfull

        &#34;&#34;&#34;

        if flags and not isinstance(flags, dict):
            raise TypeError(&#34;dict type expected&#34;)

        cfgData = self.read_config(11)
        if cfgData is None:
            return False

        if not flags:
            # return flags
            if cfgData[3] == self.BANK_EPC:
                bank = self.BANK_EPC
            elif cfgData[3] == self.BANK_TID:
                bank = self.BANK_TID
            elif cfgData[3] == self.BANK_USER:
                bank = self.BANK_USER
            else:
                bank = -1

            dbaddr = cfgData[4] * 256 + cfgData[5]
            dbn = cfgData[8] * 256 + cfgData[9]

            return {
                &#34;uid&#34;: bool(cfgData[0] &amp; 0x01),
                &#34;db&#34;: bool(cfgData[0] &amp; 0x02),
                &#34;lsb&#34;: bool(cfgData[0] &amp; 0x08),
                &#34;antno&#34;: bool(cfgData[0] &amp; 0x10),
                &#34;time&#34;: bool(cfgData[0] &amp; 0x20),
                &#34;date&#34;: bool(cfgData[0] &amp; 0x40),
                &#34;input&#34;: bool(cfgData[1] &amp; 0x01),
                &#34;mac&#34;: bool(cfgData[1] &amp; 0x02),
                &#34;antext&#34;: bool(cfgData[1] &amp; 0x10),
                &#34;antstore&#34;: bool(cfgData[2] &amp; 0x02),
                &#34;readall&#34;: bool(cfgData[2] &amp; 0x08),
                &#34;bank&#34;: bank,
                &#34;dbaddr&#34;: dbaddr,
                &#34;dbn&#34;: dbn,
            }

        try:
            trdata1 = 0
            if flags[&#34;uid&#34;] is True:
                trdata1 += 0x01
            if flags[&#34;db&#34;] is True:
                trdata1 += 0x02
            if flags[&#34;lsb&#34;] is True:
                trdata1 += 0x08
            if flags[&#34;time&#34;] is True:
                trdata1 += 0x20
            if flags[&#34;date&#34;] is True:
                trdata1 += 0x40

            trdata2 = 0
            if flags[&#34;input&#34;] is True:
                trdata2 += 0x01
            if flags[&#34;mac&#34;] is True:
                trdata2 += 0x02
            if flags[&#34;antext&#34;] is True:
                trdata2 += 0x10
                trdata1 += 0x80
            else:
                if flags[&#34;antno&#34;] is True:
                    trdata1 += 0x10

            trdata3 = 0
            if flags[&#34;antstore&#34;] is True:
                trdata3 += 0x02
            if flags[&#34;readall&#34;] is True:
                trdata3 += 0x08

            cfgData[0] = trdata1
            cfgData[1] = trdata2
            cfgData[2] = trdata3
            cfgData[3] = flags[&#34;bank&#34;]
            cfgData[4] = (flags[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[5] = (flags[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
            cfgData[8] = (flags[&#34;dbn&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[9] = (flags[&#34;dbn&#34;] &gt;&gt; 0) &amp; 0xFF

        except KeyError:
            raise ValueError(&#34;Invalid arguments&#34;)

        # write configs
        ret = self.write_config(11, cfgData)
        if ret is None:
            return False

        return True

    def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure READ MODE Filter

        Args:
            transpondervalidtime: int, This the time during which a transponder will not be reported a second time,
                                        range is from 0 - 65535 (x100msec)

            trid: dict, Sets the data source for transponder identification
            {
                &#39;source&#39;: int, values are 0=DataBlock ; 1=SerialNumber
                &#39;dbaddr&#39;: int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
                &#39;dbn&#39;: int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
            }

            inevflt: dict,
            {
                &#39;input1&#39;: bool, If True input event on input-1 will be notified
                &#39;input2&#39;: bool, If True input event on input-2 will be notified
                &#39;timeout&#39;: bool, If True timeout event during active BRM or Notification Mode will be notified
                &#39;trig&#39;: bool, If True change of the BRM or Notification Mode status will be notified
            }

        Returns:
            data: dict, current cconfiguration
            {
                &#39;transpondervalidtime&#39;: int,
                &#39;trid&#39;: {
                    &#39;source&#39;: int,
                    &#39;dbaddr&#39;: int,
                    &#39;dbn&#39;: int,
                },
                &#39;inevflt&#39;:{
                    &#39;input1&#39;: bool,
                    &#39;input2&#39;: bool,
                    &#39;timeout&#39;: bool,
                    &#39;trig&#39;: bool,
                }
            }

            True: If write successfull
        &#34;&#34;&#34;

        if transpondervalidtime and not isinstance(transpondervalidtime, int):
            raise TypeError(&#34;int type expected&#34;)

        if trid and not isinstance(trid, dict):
            raise TypeError(&#34;dict type expected&#34;)

        if inevflt and not isinstance(inevflt, int):
            raise TypeError(&#34;dict type expected&#34;)

        cfgData = self.read_config(12)
        if cfgData is None:
            return False

        if not transpondervalidtime and not trid and not inevflt:
            # return current config
            return {
                &#34;transpondervalidtime&#34;: cfgData[0] * 256 + cfgData[1],
                &#34;trid&#34;: {
                    &#34;source&#34;: 1 if (cfgData[2] &amp; 0x02) else 0,
                    &#34;dbaddr&#34;: cfgData[3] * 256 + cfgData[4],
                    &#34;dbn&#34;: cfgData[5],
                },
                &#34;inevflt&#34;: {
                    &#34;input1&#34;: bool(cfgData[6] &amp; 0x01),
                    &#34;input2&#34;: bool(cfgData[6] &amp; 0x02),
                    &#34;timeout&#34;: bool(cfgData[7] &amp; 0x02),
                    &#34;trig&#34;: bool(cfgData[7] &amp; 0x01),
                },
            }

        if transpondervalidtime:
            cfgData[0] = (transpondervalidtime &gt;&gt; 8) &amp; 0xFF
            cfgData[1] = (transpondervalidtime &gt;&gt; 0) &amp; 0xFF

        if trid:
            cfgData[2] = trid[&#34;source&#34;]
            cfgData[3] = (trid[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[4] = (trid[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
            cfgData[5] = trid[&#34;dbn&#34;]

        if inevflt:
            cfgData[6] = 0
            if inevflt[&#34;input1&#34;] is True:
                cfgData[6] += 0x01
            if inevflt[&#34;input2&#34;] is True:
                cfgData[6] += 0x02

            cfgData[7] = 0
            if inevflt[&#34;timeout&#34;] is True:
                cfgData[7] += 0x02
            if inevflt[&#34;trig&#34;] is True:
                cfgData[7] += 0x01

        # write configs
        ret = self.write_config(12, cfgData)
        if ret is None:
            return False

        return True

    def antenna_multiplexing(self, mux_enable=None, selected_antennas=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure the multiplexing of antennas in Auto Read Modes

        Args:
            mux_enable: bool, If True activates multiplexing

            selected_antennas: dict, Antennas which are used for the internal multiplexing
            {
                &#39;ant1&#39;: bool, If True antenna-1 is selected
                &#39;ant2&#39;: bool, If True antenna-2 is selected
            }

        Returns:
            bool: if antenna is configured
            dict: current multiplex configuration

        Raises:
            ValueError for incorrect data
        &#34;&#34;&#34;

        if mux_enable and not isinstance(mux_enable, bool):
            raise ValueError(&#34;bool type expected&#34;)

        if selected_antennas and not isinstance(selected_antennas, dict):
            raise ValueError(&#34;dict type expected&#34;)

        cfgData = self.read_config(15)
        if cfgData is None:
            return False

        if not mux_enable and not selected_antennas:
            # return current config
            return {
                &#34;mux_enable&#34;: bool(cfgData[0] &amp; 0x01),
                &#34;selected_antennas&#34;: {
                    &#34;ant1&#34;: bool(cfgData[1] &amp; 0x08),
                    &#34;ant2&#34;: bool(cfgData[1] &amp; 0x10),
                },
            }

        if mux_enable and mux_enable is True:
            cfgData[0] = 0x01

        if selected_antennas:
            cfgData[1] = 0x00
            if selected_antennas[&#34;ant1&#34;] is True:
                cfgData[1] += 0x08
            if selected_antennas[&#34;ant2&#34;] is True:
                cfgData[1] += 0x10

        # write configs
        ret = self.write_config(15, cfgData)
        if ret is None:
            return False

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="itekfeig.LRU1002.ANTENNA_No1"><code class="name">var <span class="ident">ANTENNA_No1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.ANTENNA_No2"><code class="name">var <span class="ident">ANTENNA_No2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.ANTENNA_No3"><code class="name">var <span class="ident">ANTENNA_No3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.ANTENNA_No4"><code class="name">var <span class="ident">ANTENNA_No4</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.ANTENNA_OFF"><code class="name">var <span class="ident">ANTENNA_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.INTERFACE_ETHERNET"><code class="name">var <span class="ident">INTERFACE_ETHERNET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.INTERFACE_SERIAL"><code class="name">var <span class="ident">INTERFACE_SERIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.MAX_ANTENNA"><code class="name">var <span class="ident">MAX_ANTENNA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.MODE_BRM"><code class="name">var <span class="ident">MODE_BRM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.MODE_HOST"><code class="name">var <span class="ident">MODE_HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.MODE_NOTIFICATION"><code class="name">var <span class="ident">MODE_NOTIFICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.MODE_SCAN"><code class="name">var <span class="ident">MODE_SCAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.POWER_FULL"><code class="name">var <span class="ident">POWER_FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.POWER_LOW"><code class="name">var <span class="ident">POWER_LOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.POWER_MEDIUM"><code class="name">var <span class="ident">POWER_MEDIUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.READER_NAME"><code class="name">var <span class="ident">READER_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.READER_TYPE"><code class="name">var <span class="ident">READER_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.RSSI_MAX"><code class="name">var <span class="ident">RSSI_MAX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU1002.RSSI_MIN"><code class="name">var <span class="ident">RSSI_MIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="itekfeig.LRU1002.antenna_multiplexing"><code class="name flex">
<span>def <span class="ident">antenna_multiplexing</span></span>(<span>self, mux_enable=None, selected_antennas=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the multiplexing of antennas in Auto Read Modes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mux_enable</code></strong></dt>
<dd>bool, If True activates multiplexing</dd>
<dt><strong><code>selected_antennas</code></strong></dt>
<dd>dict, Antennas which are used for the internal multiplexing</dd>
</dl>
<p>{
'ant1': bool, If True antenna-1 is selected
'ant2': bool, If True antenna-2 is selected
}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>if antenna is configured</dd>
<dt><code>dict</code></dt>
<dd>current multiplex configuration</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError for incorrect data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_multiplexing(self, mux_enable=None, selected_antennas=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure the multiplexing of antennas in Auto Read Modes

    Args:
        mux_enable: bool, If True activates multiplexing

        selected_antennas: dict, Antennas which are used for the internal multiplexing
        {
            &#39;ant1&#39;: bool, If True antenna-1 is selected
            &#39;ant2&#39;: bool, If True antenna-2 is selected
        }

    Returns:
        bool: if antenna is configured
        dict: current multiplex configuration

    Raises:
        ValueError for incorrect data
    &#34;&#34;&#34;

    if mux_enable and not isinstance(mux_enable, bool):
        raise ValueError(&#34;bool type expected&#34;)

    if selected_antennas and not isinstance(selected_antennas, dict):
        raise ValueError(&#34;dict type expected&#34;)

    cfgData = self.read_config(15)
    if cfgData is None:
        return False

    if not mux_enable and not selected_antennas:
        # return current config
        return {
            &#34;mux_enable&#34;: bool(cfgData[0] &amp; 0x01),
            &#34;selected_antennas&#34;: {
                &#34;ant1&#34;: bool(cfgData[1] &amp; 0x08),
                &#34;ant2&#34;: bool(cfgData[1] &amp; 0x10),
            },
        }

    if mux_enable and mux_enable is True:
        cfgData[0] = 0x01

    if selected_antennas:
        cfgData[1] = 0x00
        if selected_antennas[&#34;ant1&#34;] is True:
            cfgData[1] += 0x08
        if selected_antennas[&#34;ant2&#34;] is True:
            cfgData[1] += 0x10

    # write configs
    ret = self.write_config(15, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.antenna_power"><code class="name flex">
<span>def <span class="ident">antenna_power</span></span>(<span>self, ant, pwr_in_milliwatts:Â intÂ =Â -1) â€‘>Â Union[bool,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna Power</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ant</code></strong></dt>
<dd>must be one of supported ANTENNA_No*</dd>
<dt><strong><code>pwr_in_milliwatts</code></strong></dt>
<dd>int, in milliwats</dd>
</dl>
<p>if -1 return current power</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if power is set in the reader</dd>
<dt><code>pwr_in_milliwatts</code></dt>
<dd>int</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Given power is always adjusted to nearest valid value.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_power(self, ant, pwr_in_milliwatts: int = -1) -&gt; Union[bool, int]:
    &#34;&#34;&#34;Change Antenna Power

    Args:
        ant: must be one of supported ANTENNA_No*
        pwr_in_milliwatts: int, in milliwats
        if -1 return current power

    Returns:
        bool: True, if power is set in the reader
        pwr_in_milliwatts: int

    Raises:
        ValueError

    .. note:: Given power is always adjusted to nearest valid value.
    &#34;&#34;&#34;
    if not (
        ant is self.ANTENNA_No1
        or ant is self.ANTENNA_No2
        or ant is self.ANTENNA_No3
        or ant is self.ANTENNA_No4
    ):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    # depending upon antenna read config
    if ant is self.ANTENNA_No1:
        cfg_page = 3
    else:
        cfg_page = 20

    # Get index of respective antenna
    index = 2  # Default to Antenna1
    if ant is self.ANTENNA_No2:
        index = 10
    elif ant is self.ANTENNA_No3:
        index = 11
    elif ant is self.ANTENNA_No4:
        index = 12

    # read current configuration
    cfgData = self.read_config(cfg_page)
    if cfgData is None:
        return False

    if pwr_in_milliwatts == -1:
        return ANTENNA_POWER[cfgData[index]]

    # check antenna power
    # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
    if pwr_in_milliwatts &lt; 200:
        pwr = ANTENNA_POWER_REVERSE[100]
    elif 200 &lt;= pwr_in_milliwatts &lt; 300:
        pwr = ANTENNA_POWER_REVERSE[200]
    elif 300 &lt;= pwr_in_milliwatts &lt; 400:
        pwr = ANTENNA_POWER_REVERSE[300]
    elif 400 &lt;= pwr_in_milliwatts &lt; 500:
        pwr = ANTENNA_POWER_REVERSE[400]
    elif 500 &lt;= pwr_in_milliwatts &lt; 600:
        pwr = ANTENNA_POWER_REVERSE[500]
    elif 600 &lt;= pwr_in_milliwatts &lt; 700:
        pwr = ANTENNA_POWER_REVERSE[600]
    elif 700 &lt;= pwr_in_milliwatts &lt; 800:
        pwr = ANTENNA_POWER_REVERSE[700]
    elif 800 &lt;= pwr_in_milliwatts &lt; 900:
        pwr = ANTENNA_POWER_REVERSE[800]
    elif 900 &lt;= pwr_in_milliwatts &lt; 1000:
        pwr = ANTENNA_POWER_REVERSE[900]
    elif 1000 &lt;= pwr_in_milliwatts &lt; 1100:
        pwr = ANTENNA_POWER_REVERSE[1000]
    elif 1100 &lt;= pwr_in_milliwatts &lt; 1200:
        pwr = ANTENNA_POWER_REVERSE[1100]
    elif 1200 &lt;= pwr_in_milliwatts &lt; 1300:
        pwr = ANTENNA_POWER_REVERSE[1200]
    elif 1300 &lt;= pwr_in_milliwatts &lt; 1400:
        pwr = ANTENNA_POWER_REVERSE[1300]
    elif 1400 &lt;= pwr_in_milliwatts &lt; 1500:
        pwr = ANTENNA_POWER_REVERSE[1400]
    elif 1500 &lt;= pwr_in_milliwatts &lt; 1600:
        pwr = ANTENNA_POWER_REVERSE[1500]
    elif 1600 &lt;= pwr_in_milliwatts &lt; 1700:
        pwr = ANTENNA_POWER_REVERSE[1600]
    elif 1700 &lt;= pwr_in_milliwatts &lt; 1800:
        pwr = ANTENNA_POWER_REVERSE[1700]
    elif 1800 &lt;= pwr_in_milliwatts &lt; 1900:
        pwr = ANTENNA_POWER_REVERSE[1800]
    elif 1900 &lt;= pwr_in_milliwatts &lt; 2000:
        pwr = ANTENNA_POWER_REVERSE[1900]
    else:  # pwr_in_milliwatts &gt;= 2000:
        pwr = ANTENNA_POWER_REVERSE[2000]

    cfgData[index] = pwr

    ret = self.write_config(cfg_page, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.antenna_rssi"><code class="name flex">
<span>def <span class="ident">antenna_rssi</span></span>(<span>self, ant:Â int, rssi:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna RSSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ant</code></strong></dt>
<dd>must be one of supported ANTENNA_No*</dd>
<dt><strong><code>rssi</code></strong></dt>
<dd>must be in range RSSI_MIN and RSSI_MAX</dd>
</dl>
<p>IF rssi == 0, then itis disabled</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if power is set in the reader</dd>
<dt><code>rssi</code></dt>
<dd>current rssi value</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_rssi(self, ant: int, rssi: int):
    &#34;&#34;&#34;Change Antenna RSSI

    Args:
        ant: must be one of supported ANTENNA_No*
        rssi: must be in range RSSI_MIN and RSSI_MAX
        IF rssi == 0, then itis disabled

    Returns:
        bool: True, if power is set in the reader
        rssi: current rssi value

    Raises:
        ValueError
    &#34;&#34;&#34;
    if not (
        ant is self.ANTENNA_No1
        or ant is self.ANTENNA_No2
        or ant is self.ANTENNA_No3
        or ant is self.ANTENNA_No4
    ):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
        raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

    cfgData = self.read_config(20)
    if cfgData is None:
        return False

    # update rssi
    if ant is self.ANTENNA_No1:
        cfgData[0] = rssi

    elif ant is self.ANTENNA_No2:
        cfgData[1] = rssi

    elif ant is self.ANTENNA_No3:
        cfgData[2] = rssi

    elif ant is self.ANTENNA_No4:
        cfgData[3] = rssi

    ret = self.write_config(20, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.change_mode"><code class="name flex">
<span>def <span class="ident">change_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Reader mode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>one of the supporeted operating mode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Call get_last_error() for more reason</dd>
<dt><code>bool</code></dt>
<dd>If True, new mode is set in the reader</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode(self, mode):
    &#34;&#34;&#34;Change Reader mode

    Args:
        mode: one of the supporeted operating mode

    Returns:
        None: Call get_last_error() for more reason
        bool: If True, new mode is set in the reader
    &#34;&#34;&#34;
    cfgData = self.read_config(1)
    if cfgData is None:
        return False

    if cfgData[13] == mode:  # Current Mode is same
        FeigBase._last_error = FeigError.MODE_SAME
        return False

    # update mode
    cfgData[13] = mode

    ret = self.write_config(1, cfgData)
    if ret is None:
        return False

    FeigBase._current_mode = mode

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, interface, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the reader using one of its interface with given settings.
Onece the connection is established, a complete aconfiguration is read
from the reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong></dt>
<dd>one of the supported interface</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>of selected interface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection is sccessfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, interface, settings):
    &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
    Onece the connection is established, a complete aconfiguration is read
    from the reader.

    Args:
        interface: one of the supported interface
        settings: of selected interface

    Returns:
        bool: True if connection is sccessfull
    &#34;&#34;&#34;
    if interface == self.INTERFACE_SERIAL:
        from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
        from ..interface.feig_serial import FeigSerial

        if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
            parity = PARITY_NONE
        elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
            parity = PARITY_EVEN
        elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
            parity = PARITY_ODD
        else:
            raise ValueError(&#34;NotSupported:Parity&#34;)

        FeigBase._interface = FeigSerial()
        FeigBase._interface.open(settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity)

    elif interface == self.INTERFACE_ETHERNET:
        from ..interface.feig_ethernet import FeigEthernet

        FeigBase._interface = FeigEthernet()
        FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])

    else:
        raise ValueError(&#34;NotSupported:Interface&#34;)

    if FeigBase._interface.error != FeigError.OK:
        FeigBase._last_error = FeigBase._interface.error
        return False

    # Forced: Antenna OFF, if tags are present in the feild
    # connection to reader takes time or fail
    self.rf_onoff(self.ANTENNA_OFF)

    time.sleep(0.1)

    # Get reader type
    ret = self._get_reader_type()
    if not ret:
        logger.error(&#34;Failed to get reader ID&#34;)
        return False

    if ret != self.READER_TYPE:
        FeigBase._last_error = FeigError.INVALID_READER
        FeigBase._interface.close()
        FeigBase._interface = None
        err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
        logger.error(err_msg)
        return False

    # Get ALL INFO from the reader
    self.get_reader_info()

    time.sleep(0.1)

    # Get ALL CONFIGURATION from reader memory
    ret = self.read_all_config()
    if ret is None:
        return False

    time.sleep(0.1)

    # Configure operating modes
    from ..common.feig_host import FeigHost
    self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

    from ..common.feig_buffer_read import FeigBufferRead
    self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

    if interface == self.INTERFACE_SERIAL:
        from ..common.feig_scan import FeigScan
        self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)

    elif interface == self.INTERFACE_ETHERNET:
        from ..common.feig_notification import FeigNotification
        self.NotificationMode = FeigNotification(
            FeigBase._interface, FeigBase._last_error
        )

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.device_id"><code class="name flex">
<span>def <span class="ident">device_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns reader device ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_id(self) -&gt; str:
    &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
    return deepcopy(self._reader_info[&#34;DeviceID&#34;])</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.diagnostic"><code class="name flex">
<span>def <span class="ident">diagnostic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform reader diagnostic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostic(self):
    &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6E:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return self._diagnostic_parser(data[2:])</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from current reader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
    if FeigBase._interface:
        FeigBase._interface.close()</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get reader INPUT pin status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(self):
    &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x74:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            in1 = data[2] &amp; 0x01
            in2 = (data[2] &gt;&gt; 1) &amp; 0x01
            return in1, in2</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.get_reader_info"><code class="name flex">
<span>def <span class="ident">get_reader_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get complete reader information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reader_info(self):
    &#34;&#34;&#34;Get complete reader information
    &#34;&#34;&#34;
    if len(self._reader_info) == 0:

        for mode in READER_INFO_MODE_LIST:
            cmd = [0x66, mode]
            data = FeigBase._interface.transfer(1.0, cmd)
            if data is None:
                FeigBase._last_error = FeigError.COMM_TIMEOUT
                return

            FeigBase._last_error = FeigError.INVALID_RESPONSE
            if data[0] == 0x66:
                FeigBase._last_error = self._feig_status_parser(data[1])
                if FeigBase._last_error is FeigError.OK:
                    self._reader_info_parser(mode, data[2:])

    return deepcopy(self._reader_info)</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.notification_channel"><code class="name flex">
<span>def <span class="ident">notification_channel</span></span>(<span>self, ackData=None, dstHost=None, keepAlive=None, holdTime=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure Notification channel of the reader</p>
<h2 id="args">Args</h2>
<p>ackData:bool,
True = Acknowledge Notification Data</p>
<p>dstHost:tuple, (dstIP,dstPort)
dstIP: str, Destination IPv4
dstIP: str/int, Destination PORT from 0 - 65535</p>
<p>keepAlive:tuple, (enable, time)
enable: bool, True to enable keep alive message
time: int, keep alive message time from 0 - 65535 secs</p>
<p>holdTime:int, Defines the connection hold time from 0 - 255 sec</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>currentConfig</code></dt>
<dd>dict, If no argument is passed return current config
{
'ackData': None,
'dstHost': None,
'keepAlive': None
}</dd>
<dt><code>status</code></dt>
<dd>bool, True if configuration set successfully</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notification_channel(self, ackData=None, dstHost=None, keepAlive=None, holdTime=None)-&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure Notification channel of the reader

    Args:
        ackData:bool,
            True = Acknowledge Notification Data

        dstHost:tuple, (dstIP,dstPort)
            dstIP: str, Destination IPv4
            dstIP: str/int, Destination PORT from 0 - 65535

        keepAlive:tuple, (enable, time)
            enable: bool, True to enable keep alive message
            time: int, keep alive message time from 0 - 65535 secs

        holdTime:int, Defines the connection hold time from 0 - 255 sec

    Returns:
        currentConfig: dict, If no argument is passed return current config
            {
                &#39;ackData&#39;: None,
                &#39;dstHost&#39;: None,
                &#39;keepAlive&#39;: None
            }

        status: bool, True if configuration set successfully
    &#34;&#34;&#34;

    # check argument
    if ackData and not isinstance(ackData, bool):
        raise TypeError(&#34;bool type expected&#34;)

    if dstHost and not isinstance(dstHost, tuple):
        raise TypeError(&#34;tuple type expected&#34;)

    if keepAlive and not isinstance(keepAlive, tuple):
        raise TypeError(&#34;tuple type expected&#34;)

    if holdTime and not isinstance(holdTime, int):
        raise TypeError(&#34;int type expected&#34;)

    cfgData = self.read_config(49)
    if cfgData is None:
        return False

    if not ackData and not dstHost and not keepAlive:
        # return dictionary
        ackData = bool(cfgData[0] &amp; 0x80)

        dstIp = (
            (cfgData[7] &lt;&lt; 24)
            + (cfgData[8] &lt;&lt; 16)
            + (cfgData[9] &lt;&lt; 8)
            + cfgData[10]
        )
        dstIp = str(ipaddress.ip_address(dstIp))
        dstPort = cfgData[11] * 256 + cfgData[12]

        keepen = bool(cfgData[4] &amp; 0x01)
        keeptime = cfgData[5] * 256 + cfgData[6]

        holdTime = cfgData[13]

        return {
            &#34;ackData&#34;: ackData,
            &#34;dstHost&#34;: (dstIp, dstPort),
            &#34;keepAlive&#34;: (keepen, keeptime),
            &#34;holdTime&#34;: holdTime,
        }

    # set ack
    if ackData:
        if ackData is True:
            cfgData[0] = 0x80
        else:
            cfgData[0] = 0x00

    # keep alive
    if keepAlive:
        if keepAlive[0] is True:
            cfgData[4] = 0x01
        else:
            cfgData[4] = 0x00
        if keepAlive[1] &gt; 65535:
            raise ValueError(&#34;keepAlive time exceeds range&#34;)
        cfgData[5] = (keepAlive[1] &gt;&gt; 8) &amp; 255
        cfgData[6] = (keepAlive[1] &gt;&gt; 0) &amp; 255

    # destintation
    if dstHost:
        try:
            ipaddr = dstHost[0]
            ipaddr = int(ipaddress.ip_address(ipaddr))
            ipaddr = ipaddress.v4_int_to_packed(ipaddr)
            iperr = False
        except ipaddress.AddressValueError:
            iperr = True
        if iperr is True:
            raise ValueError(&#34;dst IP incorrect&#34;)
        cfgData[7] = ipaddr[0]
        cfgData[8] = ipaddr[1]
        cfgData[9] = ipaddr[2]
        cfgData[10] = ipaddr[3]

        if dstHost[1] &gt; 65535:
            raise ValueError(&#34;dst Port excceds range&#34;)
        cfgData[11] = (dstHost[1] &gt;&gt; 8) &amp; 255
        cfgData[12] = (dstHost[1] &gt;&gt; 0) &amp; 255

    # hold time
    if holdTime:
        if holdTime &gt; 255:
            raise ValueError(&#34;holdTime exceeds range&#34;)
        cfgData[13] = holdTime

    # write configs
    ret = self.write_config(49, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.read_mode_data"><code class="name flex">
<span>def <span class="ident">read_mode_data</span></span>(<span>self, flags=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure READ MODE data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flags</code></strong></dt>
<dd>dict, All parameters are MANDATORY</dd>
</dl>
<p>{
'uid': bool, If True reader will send IDD(EPC or EPC+TID)
'lsb': bool, If True byte order of frame will be LSB else MSB
'time': bool, If True reader will send its time
'date': bool, If True reader will send its date
'input': bool, If True reader will send its INPUT status
'mac': bool, If True reader will send its MAC address
'input': bool, If True reader will send its INPUT status</p>
<pre><code>'antno': bool, If True reader will send Antenna number
'antext': bool, If True reader will send antenna rssi, phase angle
'antstore': bool, If True reader will collect transponder data from all antennas in one data record

'readall': bool, If True reader will read complete BANK data
'bank': int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

'db': bool, If True reader will send DATA BLOCKs
'dbaddr': int, Address of first data blocks from 0 to 65535
'dbn': int, Number of data blocks from 0 to 65535
</code></pre>
<p>}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>flags</code></dt>
<dd>dict , If no argument is passed current settings is send as per above flags definitions</dd>
<dt><code>True</code></dt>
<dd>If write opertaion is successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_data(self, flags=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure READ MODE data

    Args:
        flags: dict, All parameters are MANDATORY
        {
            &#39;uid&#39;: bool, If True reader will send IDD(EPC or EPC+TID)
            &#39;lsb&#39;: bool, If True byte order of frame will be LSB else MSB
            &#39;time&#39;: bool, If True reader will send its time
            &#39;date&#39;: bool, If True reader will send its date
            &#39;input&#39;: bool, If True reader will send its INPUT status
            &#39;mac&#39;: bool, If True reader will send its MAC address
            &#39;input&#39;: bool, If True reader will send its INPUT status

            &#39;antno&#39;: bool, If True reader will send Antenna number
            &#39;antext&#39;: bool, If True reader will send antenna rssi, phase angle
            &#39;antstore&#39;: bool, If True reader will collect transponder data from all antennas in one data record

            &#39;readall&#39;: bool, If True reader will read complete BANK data
            &#39;bank&#39;: int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

            &#39;db&#39;: bool, If True reader will send DATA BLOCKs
            &#39;dbaddr&#39;: int, Address of first data blocks from 0 to 65535
            &#39;dbn&#39;: int, Number of data blocks from 0 to 65535
        }

    Returns:
        flags: dict , If no argument is passed current settings is send as per above flags definitions
        True: If write opertaion is successfull

    &#34;&#34;&#34;

    if flags and not isinstance(flags, dict):
        raise TypeError(&#34;dict type expected&#34;)

    cfgData = self.read_config(11)
    if cfgData is None:
        return False

    if not flags:
        # return flags
        if cfgData[3] == self.BANK_EPC:
            bank = self.BANK_EPC
        elif cfgData[3] == self.BANK_TID:
            bank = self.BANK_TID
        elif cfgData[3] == self.BANK_USER:
            bank = self.BANK_USER
        else:
            bank = -1

        dbaddr = cfgData[4] * 256 + cfgData[5]
        dbn = cfgData[8] * 256 + cfgData[9]

        return {
            &#34;uid&#34;: bool(cfgData[0] &amp; 0x01),
            &#34;db&#34;: bool(cfgData[0] &amp; 0x02),
            &#34;lsb&#34;: bool(cfgData[0] &amp; 0x08),
            &#34;antno&#34;: bool(cfgData[0] &amp; 0x10),
            &#34;time&#34;: bool(cfgData[0] &amp; 0x20),
            &#34;date&#34;: bool(cfgData[0] &amp; 0x40),
            &#34;input&#34;: bool(cfgData[1] &amp; 0x01),
            &#34;mac&#34;: bool(cfgData[1] &amp; 0x02),
            &#34;antext&#34;: bool(cfgData[1] &amp; 0x10),
            &#34;antstore&#34;: bool(cfgData[2] &amp; 0x02),
            &#34;readall&#34;: bool(cfgData[2] &amp; 0x08),
            &#34;bank&#34;: bank,
            &#34;dbaddr&#34;: dbaddr,
            &#34;dbn&#34;: dbn,
        }

    try:
        trdata1 = 0
        if flags[&#34;uid&#34;] is True:
            trdata1 += 0x01
        if flags[&#34;db&#34;] is True:
            trdata1 += 0x02
        if flags[&#34;lsb&#34;] is True:
            trdata1 += 0x08
        if flags[&#34;time&#34;] is True:
            trdata1 += 0x20
        if flags[&#34;date&#34;] is True:
            trdata1 += 0x40

        trdata2 = 0
        if flags[&#34;input&#34;] is True:
            trdata2 += 0x01
        if flags[&#34;mac&#34;] is True:
            trdata2 += 0x02
        if flags[&#34;antext&#34;] is True:
            trdata2 += 0x10
            trdata1 += 0x80
        else:
            if flags[&#34;antno&#34;] is True:
                trdata1 += 0x10

        trdata3 = 0
        if flags[&#34;antstore&#34;] is True:
            trdata3 += 0x02
        if flags[&#34;readall&#34;] is True:
            trdata3 += 0x08

        cfgData[0] = trdata1
        cfgData[1] = trdata2
        cfgData[2] = trdata3
        cfgData[3] = flags[&#34;bank&#34;]
        cfgData[4] = (flags[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[5] = (flags[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
        cfgData[8] = (flags[&#34;dbn&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[9] = (flags[&#34;dbn&#34;] &gt;&gt; 0) &amp; 0xFF

    except KeyError:
        raise ValueError(&#34;Invalid arguments&#34;)

    # write configs
    ret = self.write_config(11, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.read_mode_filter"><code class="name flex">
<span>def <span class="ident">read_mode_filter</span></span>(<span>self, transpondervalidtime=None, trid=None, inevflt=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure READ MODE Filter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transpondervalidtime</code></strong></dt>
<dd>int, This the time during which a transponder will not be reported a second time,
range is from 0 - 65535 (x100msec)</dd>
<dt><strong><code>trid</code></strong></dt>
<dd>dict, Sets the data source for transponder identification</dd>
</dl>
<p>{
'source': int, values are 0=DataBlock ; 1=SerialNumber
'dbaddr': int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
'dbn': int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
}</p>
<dl>
<dt><strong><code>inevflt</code></strong></dt>
<dd>dict,</dd>
</dl>
<p>{
'input1': bool, If True input event on input-1 will be notified
'input2': bool, If True input event on input-2 will be notified
'timeout': bool, If True timeout event during active BRM or Notification Mode will be notified
'trig': bool, If True change of the BRM or Notification Mode status will be notified
}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>dict, current cconfiguration</dd>
</dl>
<p>{
'transpondervalidtime': int,
'trid': {
'source': int,
'dbaddr': int,
'dbn': int,
},
'inevflt':{
'input1': bool,
'input2': bool,
'timeout': bool,
'trig': bool,
}
}</p>
<dl>
<dt><code>True</code></dt>
<dd>If write successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure READ MODE Filter

    Args:
        transpondervalidtime: int, This the time during which a transponder will not be reported a second time,
                                    range is from 0 - 65535 (x100msec)

        trid: dict, Sets the data source for transponder identification
        {
            &#39;source&#39;: int, values are 0=DataBlock ; 1=SerialNumber
            &#39;dbaddr&#39;: int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
            &#39;dbn&#39;: int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
        }

        inevflt: dict,
        {
            &#39;input1&#39;: bool, If True input event on input-1 will be notified
            &#39;input2&#39;: bool, If True input event on input-2 will be notified
            &#39;timeout&#39;: bool, If True timeout event during active BRM or Notification Mode will be notified
            &#39;trig&#39;: bool, If True change of the BRM or Notification Mode status will be notified
        }

    Returns:
        data: dict, current cconfiguration
        {
            &#39;transpondervalidtime&#39;: int,
            &#39;trid&#39;: {
                &#39;source&#39;: int,
                &#39;dbaddr&#39;: int,
                &#39;dbn&#39;: int,
            },
            &#39;inevflt&#39;:{
                &#39;input1&#39;: bool,
                &#39;input2&#39;: bool,
                &#39;timeout&#39;: bool,
                &#39;trig&#39;: bool,
            }
        }

        True: If write successfull
    &#34;&#34;&#34;

    if transpondervalidtime and not isinstance(transpondervalidtime, int):
        raise TypeError(&#34;int type expected&#34;)

    if trid and not isinstance(trid, dict):
        raise TypeError(&#34;dict type expected&#34;)

    if inevflt and not isinstance(inevflt, int):
        raise TypeError(&#34;dict type expected&#34;)

    cfgData = self.read_config(12)
    if cfgData is None:
        return False

    if not transpondervalidtime and not trid and not inevflt:
        # return current config
        return {
            &#34;transpondervalidtime&#34;: cfgData[0] * 256 + cfgData[1],
            &#34;trid&#34;: {
                &#34;source&#34;: 1 if (cfgData[2] &amp; 0x02) else 0,
                &#34;dbaddr&#34;: cfgData[3] * 256 + cfgData[4],
                &#34;dbn&#34;: cfgData[5],
            },
            &#34;inevflt&#34;: {
                &#34;input1&#34;: bool(cfgData[6] &amp; 0x01),
                &#34;input2&#34;: bool(cfgData[6] &amp; 0x02),
                &#34;timeout&#34;: bool(cfgData[7] &amp; 0x02),
                &#34;trig&#34;: bool(cfgData[7] &amp; 0x01),
            },
        }

    if transpondervalidtime:
        cfgData[0] = (transpondervalidtime &gt;&gt; 8) &amp; 0xFF
        cfgData[1] = (transpondervalidtime &gt;&gt; 0) &amp; 0xFF

    if trid:
        cfgData[2] = trid[&#34;source&#34;]
        cfgData[3] = (trid[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[4] = (trid[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
        cfgData[5] = trid[&#34;dbn&#34;]

    if inevflt:
        cfgData[6] = 0
        if inevflt[&#34;input1&#34;] is True:
            cfgData[6] += 0x01
        if inevflt[&#34;input2&#34;] is True:
            cfgData[6] += 0x02

        cfgData[7] = 0
        if inevflt[&#34;timeout&#34;] is True:
            cfgData[7] += 0x02
        if inevflt[&#34;trig&#34;] is True:
            cfgData[7] += 0x01

    # write configs
    ret = self.write_config(12, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.rf_onoff"><code class="name flex">
<span>def <span class="ident">rf_onoff</span></span>(<span>self, antno, maintainhost=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn ON/OFF individual antenna</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rf_onoff(self, antno, maintainhost=False):
    &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
    rf_output = 0
    if maintainhost is True:
        rf_output += 0x80
    rf_output += antno

    cmd = [0x6A, rf_output]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6A:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, out_rec:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set/Configure Digital Output or Relay pins</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>out_rec</code></strong></dt>
<dd>key,value as per following format
{
'type': str, 'digital' or 'relay',
'pin': int,
'mode': 'on' or 'off' or 'flash',
'freq': int, 1,2,4,8 Hz
'time': int, 1 to 65535 delay corresponds to multiple of 100milli
}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, out_rec: dict):
    &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

    Args:
        out_rec: key,value as per following format
            {
                &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                &#39;pin&#39;: int,
                &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                &#39;freq&#39;: int, 1,2,4,8 Hz
                &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
            }
    &#34;&#34;&#34;
    if out_rec[&#34;type&#34;] == &#34;digital&#34;:
        out_type = 0x00
    elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
        out_type = 0x80
    else:
        raise ValueError(&#34;Invalid Value&#34;)
    out_type = 0x80 + out_rec[&#34;pin&#34;]

    if out_rec[&#34;mode&#34;] == &#34;on&#34;:
        out_state = 0x01
    elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
        out_state = 0x02
    elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
        out_state = 0x03
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;freq&#34;] == 1:
        out_state += 0x03 * 4
    elif out_rec[&#34;freq&#34;] == 2:
        out_state += 0x02 * 4
    elif out_rec[&#34;freq&#34;] == 4:
        out_state += 0x01 * 4
    elif out_rec[&#34;freq&#34;] == 8:
        out_state += 0x00 * 4
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
        raise ValueError(&#34;Invalid Value&#34;)
    out_time = out_rec[&#34;time&#34;]

    cmd = [
        0x72,
        0x01,
        0x01,
        out_type,
        out_state,
        (out_time &gt;&gt; 8) &amp; 0xFF,
        (out_time &gt;&gt; 0) &amp; 0xFF,
    ]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x72:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.system_date_time"><code class="name flex">
<span>def <span class="ident">system_date_time</span></span>(<span>self, date_value=None, timer_value=None) â€‘>Â Union[bool,Â tuple]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_date_time(self, date_value=None, timer_value=None) -&gt; Union[bool, tuple]:
    if date_value is None and timer_value is None:
        # get
        cmd = [0x88]
    else:
        # set
        if not isinstance(date_value, tuple):
            raise ValueError(&#34;Invalid Argument {}&#34;.format(date_value))
        if not isinstance(timer_value, tuple):
            raise ValueError(&#34;Invalid Argument {}&#34;.format(timer_value))

        century = date_value[0]
        year = date_value[1]
        month = date_value[2]
        day = date_value[3]
        timezone = date_value[4]
        if (
            (century &gt; 99)
            or (year &gt; 99)
            or ((month &lt; 1) or (month &gt; 12))
            or ((day &lt; 1) or (day &gt; 31))
            or (timezone &gt; 23)
        ):
            raise ValueError(&#34;Invalid range&#34;)

        hour = timer_value[0]
        minutes = timer_value[1]
        milli = timer_value[2]
        if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
            raise ValueError(&#34;Invalid range&#34;)

        cmd = [
            0x87,
            century,
            year,
            month,
            day,
            timezone,
            hour,
            minutes,
            (milli &gt;&gt; 8) &amp; 0xFF,
            (milli &gt;&gt; 0) &amp; 0xFF,
        ]

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return False

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x87:  # Set
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    elif data[0] == 0x88:  # Get
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return (
                (data[2], data[3], data[4], data[5], data[6]),
                (data[7], data[8], (data[9] * 256 + data[10])),
            )

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU1002.system_timer"><code class="name flex">
<span>def <span class="ident">system_timer</span></span>(<span>self, timer_value=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_timer(self, timer_value=None):
    if timer_value is None:
        # get
        cmd = [0x86]
    else:
        # set
        if not isinstance(timer_value, tuple):
            raise ValueError(&#34;Invalid Argument&#34;)

        hour = timer_value[0]
        minutes = timer_value[1]
        milli = timer_value[2]
        if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
            raise ValueError(&#34;Invalid range&#34;)

        cmd = [0x85, hour, minutes, (milli &gt;&gt; 8) &amp; 0xFF, (milli &gt;&gt; 0) &amp; 0xFF]

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return False

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x85:  # Set
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    elif data[0] == 0x86:  # Get
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return data[2], data[3], (data[4] * 256 + data[5])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></b></code>:
<ul class="hlist">
<li><code><a title="itekfeig.common.feig_base.FeigBase.add_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.add_filter">add_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error">get_last_error</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error_str" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error_str">get_last_error_str</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_software_version" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_software_version">get_software_version</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.login" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.login">login</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_all_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_all_config">read_all_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_config">read_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.remove_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.remove_filter">remove_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.reset_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.reset_config">reset_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_controller_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_controller_reset">rf_controller_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_reset">rf_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.system_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.system_reset">system_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.write_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.write_config">write_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="itekfeig.LRU500i"><code class="flex name class">
<span>class <span class="ident">LRU500i</span></span>
<span>(</span><span>model)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all readers</p>
<p>Create LRU500i reader instance.</p>
<p>This reader has two models LRU500i-BD and LRU500i-PoE.
If invalid model is given then PoE model is considered.</p>
<h2 id="argument">Argument</h2>
<p>model:str, 'poe' ==&gt; LRU500i-PoE, 'bd' ==&gt; LRU500i-BD</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LRU500i(FeigBase):
    READER_NAME = &#34;&#34;
    READER_TYPE = &#34;&#34;

    INTERFACE_SERIAL = 0
    INTERFACE_ETHERNET = 1

    MODE_HOST = 0x00
    MODE_SCAN = 0x01
    MODE_BRM = 0x80
    MODE_NOTIFICATION = 0xC0

    ANTENNA_OFF = 0x00

    ANTENNA_No1 = 0x01
    ANTENNA_No2 = 0x02

    MAX_ANTENNA = 2

    POWER_LOW = 100
    POWER_MEDIUM = 400
    POWER_FULL = 800

    RSSI_MIN = 0
    RSSI_MAX = 255

    def __init__(self, model):
        &#34;&#34;&#34;Create LRU500i reader instance.

        This reader has two models LRU500i-BD and LRU500i-PoE.
        If invalid model is given then PoE model is considered.
        Argument:
            model:str, &#39;poe&#39; ==&gt; LRU500i-PoE, &#39;bd&#39; ==&gt; LRU500i-BD
        &#34;&#34;&#34;
        super().__init__()

        # identify model
        if model == &#34;bd&#34;:
            self.READER_NAME = &#34;LRU500i-BD&#34;
        else:
            self.READER_NAME = &#34;LRU500i-PoE&#34;
        self.READER_TYPE = FEIG_READER_IDS[self.READER_NAME]

        self._reader_info = {}
        self._device_id = None

    ##########################################################################
    ####    READER CONNECTION API
    ##########################################################################

    def connect(self, interface, settings):
        &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
        Onece the connection is established, a complete aconfiguration is read
        from the reader.

        Args:
            interface: one of the supported interface
            settings: of selected interface

        Returns:
            bool: True if connection is sccessfull
        &#34;&#34;&#34;
        if interface == self.INTERFACE_SERIAL:
            from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
            from ..interface.feig_serial import FeigSerial

            if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
                parity = PARITY_NONE
            elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
                parity = PARITY_EVEN
            elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
                parity = PARITY_ODD
            else:
                raise ValueError(&#34;NotSupported:Parity&#34;)

            FeigBase._interface = FeigSerial()
            FeigBase._interface.open(settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity)

        elif interface == self.INTERFACE_ETHERNET:
            from ..interface.feig_ethernet import FeigEthernet

            FeigBase._interface = FeigEthernet()
            FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])

        else:
            raise ValueError(&#34;NotSupported:Interface&#34;)

        if FeigBase._interface.error != FeigError.OK:
            FeigBase._last_error = FeigBase._interface.error
            return False

        # Forced: Antenna OFF, if tags are present in the feild
        # connection to reader takes time or fail
        self.rf_onoff(self.ANTENNA_OFF)

        time.sleep(0.1)

        # Get reader type
        ret = self._get_reader_type()
        if not ret:
            logger.error(&#34;Failed to get reader ID&#34;)
            return False

        if ret != self.READER_TYPE:
            FeigBase._last_error = FeigError.INVALID_READER
            FeigBase._interface.close()
            FeigBase._interface = None
            err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
            logger.error(err_msg)
            return False

        # Get ALL INFO from the reader
        self.get_reader_info()

        time.sleep(0.1)

        # Get ALL CONFIGURATION from reader memory
        ret = self.read_all_config()
        if ret is None:
            return False

        time.sleep(0.1)

        # Configure operating modes
        from ..common.feig_host import FeigHost

        self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

        from ..common.feig_buffer_read import FeigBufferRead

        self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

        if interface == self.INTERFACE_SERIAL:
            from ..common.feig_scan import FeigScan

            self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)
        elif interface == self.INTERFACE_ETHERNET:
            from ..common.feig_notification import FeigNotification

            self.NotificationMode = FeigNotification(
                FeigBase._interface, FeigBase._last_error
            )

        return True

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
        if FeigBase._interface:
            FeigBase._interface.close()

    ##########################################################################
    ####    READER CONTROL API
    ##########################################################################

    def rf_onoff(self, antno, maintainhost=False):
        &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
        rf_output = 0
        if maintainhost is True:
            rf_output += 0x80
        rf_output += antno

        cmd = [0x6A, rf_output]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6A:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        return False

    def set_output(self, out_rec: dict):
        &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

        Args:
            out_rec: key,value as per following format
                {
                    &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                    &#39;pin&#39;: int,
                    &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                    &#39;freq&#39;: int, 1,2,4,8 Hz
                    &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
                }
        &#34;&#34;&#34;
        if out_rec[&#34;type&#34;] == &#34;digital&#34;:
            out_type = 0x00
        elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
            out_type = 0x80
        else:
            raise ValueError(&#34;Invalid Value&#34;)
        out_type = 0x80 + out_rec[&#34;pin&#34;]

        if out_rec[&#34;mode&#34;] == &#34;on&#34;:
            out_state = 0x01
        elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
            out_state = 0x02
        elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
            out_state = 0x03
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;freq&#34;] == 1:
            out_state += 0x03 * 4
        elif out_rec[&#34;freq&#34;] == 2:
            out_state += 0x02 * 4
        elif out_rec[&#34;freq&#34;] == 4:
            out_state += 0x01 * 4
        elif out_rec[&#34;freq&#34;] == 8:
            out_state += 0x00 * 4
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
            raise ValueError(&#34;Invalid Value&#34;)
        out_time = out_rec[&#34;time&#34;]

        cmd = [
            0x72,
            0x01,
            0x01,
            out_type,
            out_state,
            (out_time &gt;&gt; 8) &amp; 0xFF,
            (out_time &gt;&gt; 0) &amp; 0xFF,
        ]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x72:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

    def get_input(self):
        &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x74:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                in1 = data[2] &amp; 0x01
                in2 = (data[2] &gt;&gt; 1) &amp; 0x01
                return in1, in2

    def change_mode(self, mode):
        &#34;&#34;&#34;Change Reader mode

        Args:
            mode: one of the supporeted operating mode

        Returns:
            None: Call get_last_error() for more reason
            bool: If True, new mode is set in the reader
        &#34;&#34;&#34;
        cfgData = self.read_config(1)
        if cfgData is None:
            return False

        if cfgData[13] == mode:  # Current Mode is same
            FeigBase._last_error = FeigError.MODE_SAME
            return False

        # update mode
        cfgData[13] = mode

        ret = self.write_config(1, cfgData)
        if ret is None:
            return False

        FeigBase._current_mode = mode

        return True

    @staticmethod
    def _diagnostic_parser(data):

        def test_error(x) -&gt; str:
            if x: return &#34;FAIL&#34;
            return &#34;OK&#34;

        diag = {}
        data_set = data[0]
        offset = 1
        for _ in range(0, data_set):
            mode = data[offset]
            if mode == 0x01:
                flag_a = data[offset + 1]
                flag_b = data[offset + 2]

                rf_status = {}
                rf_status[&#34;POWER&#34;] = test_error(flag_a &amp; 0x10)
                rf_status[&#34;TEMP_WARNING&#34;] = test_error(flag_a &amp; 0x20)
                rf_status[&#34;TEMP_ALARM&#34;] = test_error(flag_a &amp; 0x80)

                # ANTENNA FLAGS are SET when impedance |Z| != 50
                rf_status[&#34;Antenna1&#34;] = test_error(flag_b &amp; 0x01)
                rf_status[&#34;Antenna2&#34;] = test_error(flag_b &amp; 0x02)

                diag[&#34;RF_Status&#34;] = rf_status

            elif mode == 0x04:
                # EEPROM
                eeprom = {}
                int_error = data[offset + 1] * 256 + data[offset + 2]

                eeprom[&#34;EE_DEV1&#34;] = test_error(int_error &amp; 0x0001)
                eeprom[&#34;RF_DECODER&#34;] = test_error(int_error &amp; 0x0004)
                eeprom[&#34;RTC&#34;] = test_error(int_error &amp; 0x0040)
                eeprom[&#34;ADC&#34;] = test_error(int_error &amp; 0x0080)
                eeprom[&#34;IO_EXPANDER&#34;] = test_error(int_error &amp; 0x0100)
                eeprom[&#34;DC_OUT&#34;] = test_error(int_error &amp; 0x0200)
                eeprom[&#34;USB_COMM&#34;] = test_error(int_error &amp; 0x0400)

                diag[&#34;Eeprom&#34;] = eeprom

            elif mode == 0x20:
                # FIRMWARE
                diag[&#34;Firmware&#34;] = data[offset + 1 :].rstrip(b&#34;\x00&#34;).decode(&#34;ascii&#34;)

            offset = offset + 30 + 1

        return diag

    def diagnostic(self):
        &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6E:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return self._diagnostic_parser(data[2:])

    ##########################################################################
    ####    READER INFO API
    ##########################################################################
    def _get_reader_type(self):
        cmd = [0x02, 0x00, 0x08, 0xFF, 0x66, 0x00, 0x88, 0x12]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x66:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                if data[6] == FEIG_READER_IDS[&#34;LRU500i&#34;]:
                    if data[16] == ASSEMBLY_LRU500iBD:
                        return FEIG_READER_IDS[&#34;LRU500i-BD&#34;]
                    elif data[16] == ASSEMBLY_LRU500iPOE:
                        return FEIG_READER_IDS[&#34;LRU500i-PoE&#34;]

                return 0xFF  # invalid reader

    def _reader_info_parser(self, mode, data):
        if mode == 0x00:
            self._reader_info[&#34;RFControllerSoftwareRevision&#34;] = hexlify(
                data[0:3]
            ).decode(&#34;ascii&#34;)
            self._reader_info[&#34;HardwareType&#34;] = hexlify(data[3:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;ReaderType&#34;] = int(data[4])
            self._reader_info[&#34;TransponderTypes&#34;] = hexlify(data[5:7]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;MaxRXBufferSize&#34;] = data[7] * 256 + data[8]
            self._reader_info[&#34;MaxTXBufferSize&#34;] = data[9] * 256 + data[10]
            self._reader_info[&#34;ReaderRevision&#34;] = data[13]
            self._reader_info[&#34;ReaderAssembly&#34;] = data[14]

            if self._reader_info[&#34;ReaderType&#34;] == FEIG_READER_IDS[&#34;LRU500i&#34;]:
                if self._reader_info[&#34;ReaderAssembly&#34;] == ASSEMBLY_LRU500iBD:
                    self._reader_info[&#34;ReaderType&#34;] = FEIG_READER_IDS[&#34;LRU500i-BD&#34;]
                elif self._reader_info[&#34;ReaderAssembly&#34;] == ASSEMBLY_LRU500iPOE:
                    self._reader_info[&#34;ReaderType&#34;] = FEIG_READER_IDS[&#34;LRU500i-PoE&#34;]
                else:
                    # Incorrect reader
                    self._reader_info[&#34;ReaderType&#34;] = 0xFF

        elif mode == 0x05:
            self._reader_info[&#34;BootloaderSoftwareRevison&#34;] = hexlify(data[0:2]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x10:
            internal_use = (
                hexlify(data[0:2]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[2:4]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[4:6]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;InternalUse&#34;] = internal_use

            freq = &#34;&#34;
            if data[6] &amp; 0x80:
                freq += &#34;HF,&#34;
            if data[6] &amp; 0x40:
                freq += &#34;UHF,&#34;
            if data[6] &amp; 0x04:
                freq += &#34;LOCK,&#34;
            else:
                freq += &#34;UNLOCK,&#34;
            if data[6] &amp; 0x02:
                freq += &#34;FCC,&#34;
            if data[6] &amp; 0x01:
                freq += &#34;EU&#34;
            self._reader_info[&#34;Frequency&#34;] = freq

            prt = &#34;&#34;
            if data[7] &amp; 0x01:
                prt += &#34;SERIAL,&#34;
            if data[7] &amp; 0x02:
                prt += &#34;RS485,&#34;
            if data[7] &amp; 0x04:
                prt += &#34;LAN,&#34;
            if data[7] &amp; 0x08:
                prt += &#34;WLAN,&#34;
            if data[7] &amp; 0x10:
                prt += &#34;USB,&#34;
            if data[7] &amp; 0x20:
                prt += &#34;BT,&#34;
            if data[7] &amp; 0x80:
                prt += &#34;DISCOVERY&#34;
            self._reader_info[&#34;SupportedPorts&#34;] = prt

        elif mode == 0x15:
            self._reader_info[&#34;RFStackSoftwareRevision&#34;] = hexlify(data[0:2]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x40:
            self._reader_info[&#34;ReadPages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;ReadPermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x41:
            self._reader_info[&#34;WritePages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;WritePermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x50:
            # if data[0] &amp; 0x02:
            #     self._reader_info[&#34;Supported_v4&#34;] = &#34;Yes&#34;
            # else:
            #     self._reader_info[&#34;Supported_v4&#34;] = &#34;No&#34;
            # if data[0] &amp; 0x08:
            #     self._reader_info[&#34;Disabled_v4&#34;] = &#34;Yes&#34;
            # else:
            #     self._reader_info[&#34;Disabled_v4&#34;] = &#34;No&#34;
            # if data[0] &amp; 0x20:
            #     self._reader_info[&#34;DHCP_v4&#34;] = &#34;Yes&#34;
            # else:
            #     self._reader_info[&#34;DHCP_v4&#34;] = &#34;No&#34;

            mac = (
                hexlify(data[1:2]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[2:3]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[3:4]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[4:5]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[5:6]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[6:7]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;MACAddress&#34;] = mac

        elif mode == 0x51:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                ip = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Address&#34;] = ip
            else:
                self._reader_info[&#34;IPv4Address&#34;] = &#34;NA&#34;

        elif mode == 0x52:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                nm = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Netmask&#34;] = nm
            else:
                self._reader_info[&#34;IPv4Netmask&#34;] = &#34;NA&#34;

        elif mode == 0x53:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                gw = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Gateway&#34;] = gw
            else:
                self._reader_info[&#34;IPv4Gateway&#34;] = &#34;NA&#34;

        elif mode == 0x60:
            self._reader_info[&#34;Inputs&#34;] = data[0]
            self._reader_info[&#34;Outputs&#34;] = data[1]
            self._reader_info[&#34;Relays&#34;] = data[2]

        elif mode == 0x80:
            self._reader_info[&#34;DeviceID&#34;] = hexlify(data[0:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;CustomerID&#34;] = hexlify(data[4:8]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;FirmwareVersion&#34;] = hexlify(data[8:10]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;TransponderDriver&#34;] = hexlify(data[10:12]).decode(
                &#34;ascii&#34;
            )
            self._reader_info[&#34;FirmwareFunctions&#34;] = hexlify(data[12:14]).decode(
                &#34;ascii&#34;
            )

    def get_reader_info(self):
        &#34;&#34;&#34;Get complete reader information

        &#34;&#34;&#34;
        if len(self._reader_info) == 0:

            for mode in READER_INFO_MODE_LIST:
                cmd = [0x66, mode]
                data = FeigBase._interface.transfer(1.0, cmd)
                if data is None:
                    FeigBase._last_error = FeigError.COMM_TIMEOUT
                    return

                FeigBase._last_error = FeigError.INVALID_RESPONSE
                if data[0] == 0x66:
                    FeigBase._last_error = self._feig_status_parser(data[1])
                    if FeigBase._last_error is FeigError.OK:
                        self._reader_info_parser(mode, data[2:])

        return deepcopy(self._reader_info)

    def device_id(self) -&gt; str:
        &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
        return deepcopy(self._reader_info[&#34;DeviceID&#34;])

    ##########################################################################
    ####    READER CONFIGURATION API
    ##########################################################################

    def antenna_power(self, ant: int, pwr_in_milliwatts: int = -1) -&gt; Union[bool, int]:
        &#34;&#34;&#34;Change Antenna Power

        Args:
            ant: must be one of supported ANTENNA_No*
            pwr_in_milliwatts: int, in milliwats
            if -1 return current power

        Returns:
            bool: True, if power is set in the reader
            pwr_in_milliwatts: int

        Raises:
            ValueError

        .. note:: Given power is always adjusted to nearest valid value.
        &#34;&#34;&#34;
        if not (ant is self.ANTENNA_No1 or ant is self.ANTENNA_No2):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        # depending upon antenna read config
        if ant is self.ANTENNA_No1:
            cfg_page = 3
        else:
            cfg_page = 20

        # Get index of respective antenna
        index = 2  # Default to Antenna1
        if ant is self.ANTENNA_No2:
            index = 10

        # read current configuration
        cfgData = self.read_config(cfg_page)
        if cfgData is None:
            return False

        if pwr_in_milliwatts == -1:
            return ANTENNA_POWER[cfgData[index]]

        # check antenna power
        # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
        if pwr_in_milliwatts &lt; 200:
            pwr = ANTENNA_POWER_REVERSE[100]
        elif 200 &lt;= pwr_in_milliwatts &lt; 300:
            pwr = ANTENNA_POWER_REVERSE[200]
        elif 300 &lt;= pwr_in_milliwatts &lt; 400:
            pwr = ANTENNA_POWER_REVERSE[300]
        elif 400 &lt;= pwr_in_milliwatts &lt; 500:
            pwr = ANTENNA_POWER_REVERSE[400]
        elif 500 &lt;= pwr_in_milliwatts &lt; 600:
            pwr = ANTENNA_POWER_REVERSE[500]
        elif 600 &lt;= pwr_in_milliwatts &lt; 700:
            pwr = ANTENNA_POWER_REVERSE[600]
        elif 700 &lt;= pwr_in_milliwatts &lt; 800:
            pwr = ANTENNA_POWER_REVERSE[700]
        else:  # pwr_in_milliwatts &gt;= 800:
            pwr = ANTENNA_POWER_REVERSE[800]

        cfgData[index] = pwr

        ret = self.write_config(cfg_page, cfgData)
        if ret is None:
            return False

        return True

    def antenna_rssi(self, ant: int, rssi: int) -&gt; Union[bool, int]:
        &#34;&#34;&#34;Change Antenna RSSI
        Args:
            ant: must be one of supported ANTENNA_No*
            rssi: must be in range RSSI_MIN and RSSI_MAX
            IF rssi == 0, then itis disabled

        Returns:
            bool: True, if power is set in the reader
            rssi: current rssi value

        Raises:
            ValueError
        &#34;&#34;&#34;
        if not (ant is self.ANTENNA_No1 or ant is self.ANTENNA_No2):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
            raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

        cfgData = self.read_config(20)
        if cfgData is None:
            return False

        # update rssi
        if ant is self.ANTENNA_No1:
            cfgData[0] = rssi

        elif ant is self.ANTENNA_No2:
            cfgData[1] = rssi

        ret = self.write_config(20, cfgData)
        if ret is None:
            return False

        return True

    def system_date_time(self, date_value=None, timer_value=None) -&gt; Union[bool, tuple]:
        if date_value is None and timer_value is None:
            # get
            cmd = [0x88]
        else:
            # set
            if not isinstance(date_value, tuple):
                raise ValueError(&#34;Invalid Argument:{}&#34;.format(date_value))
            if not isinstance(timer_value, tuple):
                raise ValueError(&#34;Invalid Argument:{}&#34;.format(timer_value))

            century = date_value[0]
            year = date_value[1]
            month = date_value[2]
            day = date_value[3]
            timezone = date_value[4]
            if (
                (century &gt; 99) or (year &gt; 99)
                or ((month &lt; 1) or (month &gt; 12))
                or ((day &lt; 1) or (day &gt; 31))
                or (timezone &gt; 23)
            ):
                raise ValueError(&#34;Invalid range&#34;)

            hour = timer_value[0]
            minutes = timer_value[1]
            milli = timer_value[2]
            if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
                raise ValueError(&#34;Invalid range&#34;)

            cmd = [
                0x87,
                century,
                year,
                month,
                day,
                timezone,
                hour,
                minutes,
                (milli &gt;&gt; 8) &amp; 0xFF,
                (milli &gt;&gt; 0) &amp; 0xFF,
            ]

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return False

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x87:  # Set
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        elif data[0] == 0x88:  # Get
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return (
                    (data[2], data[3], data[4], data[5], data[6]),
                    (data[7], data[8], (data[9] * 256 + data[10])),
                )

        return False

    def notification_channel(self, ackData=None, dstHost=None, keepAlive=None, holdTime=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure Notification channel of the reader

        Args:
            ackData:bool,
                True = Acknowledge Notification Data

            dstHost:tuple, (dstIP,dstPort)
                dstIP: str, Destination IPv4
                dstIP: str/int, Destination PORT from 0 - 65535

            keepAlive:tuple, (enable, time)
                enable: bool, True to enable keep alive message
                time: int, keep alive message time from 0 - 65535 secs

            holdTime:int, Defines the connection hold time from 0 - 255 sec

        Returns:
            currentConfig: dict, If no argument is passed return current config
                {
                    &#39;ackData&#39;: None,
                    &#39;dstHost&#39;: None,
                    &#39;keepAlive&#39;: None
                }

            status: bool, True if configuration set successfully
        &#34;&#34;&#34;

        # check argument
        if ackData and not isinstance(ackData, bool):
            raise TypeError(&#34;bool type expected&#34;)

        if dstHost and not isinstance(dstHost, tuple):
            raise TypeError(&#34;tuple type expected&#34;)

        if keepAlive and not isinstance(keepAlive, tuple):
            raise TypeError(&#34;tuple type expected&#34;)

        if holdTime and not isinstance(holdTime, int):
            raise TypeError(&#34;int type expected&#34;)

        cfgData = self.read_config(49)
        if cfgData is None:
            return False

        if not ackData and not dstHost and not keepAlive:
            # return dictionary
            ackData = bool(cfgData[0] &amp; 0x80)

            dstIp = (cfgData[7] &lt;&lt; 24)
            dstIp += (cfgData[8] &lt;&lt; 16)
            dstIp += (cfgData[9] &lt;&lt; 8)
            dstIp += cfgData[10]

            dstIp = str(ipaddress.ip_address(dstIp))
            dstPort = cfgData[11] * 256 + cfgData[12]

            keepen = bool(cfgData[4] &amp; 0x01)
            keeptime = cfgData[5] * 256 + cfgData[6]

            holdTime = cfgData[13]

            return {
                &#34;ackData&#34;: ackData,
                &#34;dstHost&#34;: (dstIp, dstPort),
                &#34;keepAlive&#34;: (keepen, keeptime),
                &#34;holdTime&#34;: holdTime,
            }

        # set ack
        if ackData:
            if ackData is True:
                cfgData[0] = 0x80
            else:
                cfgData[0] = 0x00

        # keep alive
        if keepAlive:
            if keepAlive[0] is True:
                cfgData[4] = 0x01
            else:
                cfgData[4] = 0x00
            if keepAlive[1] &gt; 65535:
                raise ValueError(&#34;keepAlive time exceeds range&#34;)
            cfgData[5] = (keepAlive[1] &gt;&gt; 8) &amp; 255
            cfgData[6] = (keepAlive[1] &gt;&gt; 0) &amp; 255

        # destintation
        if dstHost:
            try:
                ipaddr = dstHost[0]
                ipaddr = int(ipaddress.ip_address(ipaddr))
                ipaddr = ipaddress.v4_int_to_packed(ipaddr)
                iperr = False
            except ipaddress.AddressValueError:
                iperr = True
            if iperr is True:
                raise ValueError(&#34;dst IP incorrect&#34;)
            cfgData[7] = ipaddr[0]
            cfgData[8] = ipaddr[1]
            cfgData[9] = ipaddr[2]
            cfgData[10] = ipaddr[3]

            if dstHost[1] &gt; 65535:
                raise ValueError(&#34;dst Port excceds range&#34;)
            cfgData[11] = (dstHost[1] &gt;&gt; 8) &amp; 255
            cfgData[12] = (dstHost[1] &gt;&gt; 0) &amp; 255

        # hold time
        if holdTime:
            if holdTime &gt; 255:
                raise ValueError(&#34;holdTime exceeds range&#34;)
            cfgData[13] = holdTime

        # write configs
        ret = self.write_config(49, cfgData)
        if ret is None:
            return False

        return True

    def read_mode_data(self, flags=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure READ MODE data

        Args:
            flags: dict, All parameters are MANDATORY
            {
                &#39;uid&#39;: bool, If True reader will send IDD(EPC or EPC+TID)
                &#39;lsb&#39;: bool, If True byte order of frame will be LSB else MSB
                &#39;time&#39;: bool, If True reader will send its time
                &#39;date&#39;: bool, If True reader will send its date
                &#39;input&#39;: bool, If True reader will send its INPUT status
                &#39;mac&#39;: bool, If True reader will send its MAC address
                &#39;input&#39;: bool, If True reader will send its INPUT status

                &#39;antno&#39;: bool, If True reader will send Antenna number
                &#39;antext&#39;: bool, If True reader will send antenna rssi, phase angle
                &#39;antstore&#39;: bool, If True reader will collect transponder data from all antennas in one data record

                &#39;readall&#39;: bool, If True reader will read complete BANK data
                &#39;bank&#39;: int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

                &#39;db&#39;: bool, If True reader will send DATA BLOCKs
                &#39;dbaddr&#39;: int, Address of first data blocks from 0 to 65535
                &#39;dbn&#39;: int, Number of data blocks from 0 to 65535
            }

        Returns:
            flags: dict , If no argument is passed current settings is send as per above flags definitions
            True: If write opertaion is successfull

        &#34;&#34;&#34;

        if flags and not isinstance(flags, dict):
            raise TypeError(&#34;dict type expected&#34;)

        cfgData = self.read_config(11)
        if cfgData is None:
            return False

        if not flags:
            # return flags
            if cfgData[3] == self.BANK_EPC:
                bank = self.BANK_EPC
            elif cfgData[3] == self.BANK_TID:
                bank = self.BANK_TID
            elif cfgData[3] == self.BANK_USER:
                bank = self.BANK_USER
            else:
                bank = -1

            dbaddr = cfgData[4] * 256 + cfgData[5]
            dbn = cfgData[8] * 256 + cfgData[9]

            return {
                &#34;uid&#34;: bool(cfgData[0] &amp; 0x01),
                &#34;db&#34;: bool(cfgData[0] &amp; 0x02),
                &#34;lsb&#34;: bool(cfgData[0] &amp; 0x08),
                &#34;antno&#34;: bool(cfgData[0] &amp; 0x10),
                &#34;time&#34;: bool(cfgData[0] &amp; 0x20),
                &#34;date&#34;: bool(cfgData[0] &amp; 0x40),
                &#34;input&#34;: bool(cfgData[1] &amp; 0x01),
                &#34;mac&#34;: bool(cfgData[1] &amp; 0x02),
                &#34;antext&#34;: bool(cfgData[1] &amp; 0x10),
                &#34;antstore&#34;: bool(cfgData[2] &amp; 0x02),
                &#34;readall&#34;: bool(cfgData[2] &amp; 0x08),
                &#34;bank&#34;: bank,
                &#34;dbaddr&#34;: dbaddr,
                &#34;dbn&#34;: dbn,
            }

        try:
            trdata1 = 0
            if flags[&#34;uid&#34;] is True:
                trdata1 += 0x01
            if flags[&#34;db&#34;] is True:
                trdata1 += 0x02
            if flags[&#34;lsb&#34;] is True:
                trdata1 += 0x08
            if flags[&#34;time&#34;] is True:
                trdata1 += 0x20
            if flags[&#34;date&#34;] is True:
                trdata1 += 0x40

            trdata2 = 0
            if flags[&#34;input&#34;] is True:
                trdata2 += 0x01
            if flags[&#34;mac&#34;] is True:
                trdata2 += 0x02
            if flags[&#34;antext&#34;] is True:
                trdata2 += 0x10
                trdata1 += 0x80
            else:
                if flags[&#34;antno&#34;] is True:
                    trdata1 += 0x10

            trdata3 = 0
            if flags[&#34;antstore&#34;] is True:
                trdata3 += 0x02
            if flags[&#34;readall&#34;] is True:
                trdata3 += 0x08

            cfgData[0] = trdata1
            cfgData[1] = trdata2
            cfgData[2] = trdata3
            cfgData[3] = flags[&#34;bank&#34;]
            cfgData[4] = (flags[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[5] = (flags[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
            cfgData[8] = (flags[&#34;dbn&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[9] = (flags[&#34;dbn&#34;] &gt;&gt; 0) &amp; 0xFF

        except KeyError:
            raise ValueError(&#34;Invalid arguments&#34;)

        # write configs
        ret = self.write_config(11, cfgData)
        if ret is None:
            return False

        return True

    def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure READ MODE Filter

        Args:
            transpondervalidtime: int, This the time during which a transponder will not be reported a second time,
                                        range is from 0 - 65535 (x100msec)

            trid: dict, Sets the data source for transponder identification
            {
                &#39;source&#39;: int, values are 0=DataBlock ; 1=SerialNumber
                &#39;dbaddr&#39;: int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
                &#39;dbn&#39;: int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
            }

            inevflt: dict,
            {
                &#39;input1&#39;: bool, If True input event on input-1 will be notified
                &#39;input2&#39;: bool, If True input event on input-2 will be notified
                &#39;timeout&#39;: bool, If True timeout event during active BRM or Notification Mode will be notified
                &#39;trig&#39;: bool, If True change of the BRM or Notification Mode status will be notified
            }

        Returns:
            data: dict, current cconfiguration
            {
                &#39;transpondervalidtime&#39;: int,
                &#39;trid&#39;: {
                    &#39;source&#39;: int,
                    &#39;dbaddr&#39;: int,
                    &#39;dbn&#39;: int,
                },
                &#39;inevflt&#39;:{
                    &#39;input1&#39;: bool,
                    &#39;input2&#39;: bool,
                    &#39;timeout&#39;: bool,
                    &#39;trig&#39;: bool,
                }
            }

            True: If write successfull
        &#34;&#34;&#34;

        if transpondervalidtime and not isinstance(transpondervalidtime, int):
            raise TypeError(&#34;int type expected&#34;)

        if trid and not isinstance(trid, dict):
            raise TypeError(&#34;dict type expected&#34;)

        if inevflt and not isinstance(inevflt, int):
            raise TypeError(&#34;dict type expected&#34;)

        cfgData = self.read_config(12)
        if cfgData is None:
            return False

        if not transpondervalidtime and not trid and not inevflt:
            # return current config
            return {
                &#34;transpondervalidtime&#34;: cfgData[0] * 256 + cfgData[1],
                &#34;trid&#34;: {
                    &#34;source&#34;: 1 if (cfgData[2] &amp; 0x02) else 0,
                    &#34;dbaddr&#34;: cfgData[3] * 256 + cfgData[4],
                    &#34;dbn&#34;: cfgData[5],
                },
                &#34;inevflt&#34;: {
                    &#34;input1&#34;: bool(cfgData[6] &amp; 0x01),
                    &#34;input2&#34;: bool(cfgData[6] &amp; 0x02),
                    &#34;timeout&#34;: bool(cfgData[7] &amp; 0x02),
                    &#34;trig&#34;: bool(cfgData[7] &amp; 0x01),
                },
            }

        if transpondervalidtime:
            cfgData[0] = (transpondervalidtime &gt;&gt; 8) &amp; 0xFF
            cfgData[1] = (transpondervalidtime &gt;&gt; 0) &amp; 0xFF

        if trid:
            cfgData[2] = trid[&#34;source&#34;]
            cfgData[3] = (trid[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
            cfgData[4] = (trid[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
            cfgData[5] = trid[&#34;dbn&#34;]

        if inevflt:
            cfgData[6] = 0
            if inevflt[&#34;input1&#34;] is True:
                cfgData[6] += 0x01
            if inevflt[&#34;input2&#34;] is True:
                cfgData[6] += 0x02

            cfgData[7] = 0
            if inevflt[&#34;timeout&#34;] is True:
                cfgData[7] += 0x02
            if inevflt[&#34;trig&#34;] is True:
                cfgData[7] += 0x01

        # write configs
        ret = self.write_config(12, cfgData)
        if ret is None:
            return False

        return True

    def antenna_multiplexing(self, mux_enable=None, selected_antennas=None) -&gt; Union[bool, dict]:
        &#34;&#34;&#34;Configure the multiplexing of antennas in Auto Read Modes

        Args:
            mux_enable: bool, If True activates multiplexing

            selected_antennas: dict, Antennas which are used for the internal multiplexing
            {
                &#39;ant1&#39;: bool, If True antenna-1 is selected
                &#39;ant2&#39;: bool, If True antenna-2 is selected
            }

        Returns:
            bool: if antenna is configured
            dict: current multiplex configuration

        Raises:
            ValueError for incorrect data
        &#34;&#34;&#34;

        if mux_enable and not isinstance(mux_enable, bool):
            raise ValueError(&#34;bool type expected&#34;)

        if selected_antennas and not isinstance(selected_antennas, dict):
            raise ValueError(&#34;dict type expected&#34;)

        cfgData = self.read_config(15)
        if cfgData is None:
            return False

        if not mux_enable and not selected_antennas:
            # return current config
            return {
                &#34;mux_enable&#34;: bool(cfgData[0] &amp; 0x01),
                &#34;selected_antennas&#34;: {
                    &#34;ant1&#34;: bool(cfgData[1] &amp; 0x08),
                    &#34;ant2&#34;: bool(cfgData[1] &amp; 0x10),
                },
            }

        if mux_enable and mux_enable is True:
            cfgData[0] = 0x01

        if selected_antennas:
            cfgData[1] = 0x00
            if selected_antennas[&#34;ant1&#34;] is True:
                cfgData[1] += 0x08
            if selected_antennas[&#34;ant2&#34;] is True:
                cfgData[1] += 0x10

        # write configs
        ret = self.write_config(15, cfgData)
        if ret is None:
            return False

        return True

    def signaler(self, traffic: dict = None, buzzer: bool = None):
        &#34;&#34;&#34;This function configures in-built TrafficLight, Buzzer of the reader.

        Args:
            traffic: dict,
            {
                &#39;idle&#39;:str, Defines the status of the traffic lights during the idle mode.
                            Values are &#39;off&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;

                &#39;tag&#39;:str, Defines the color the reader uses to signalize that a transponder has been read.
                            Values are &#39;off&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;

                &#39;flash&#39;:int, Defines the flashing frequency the reader uses to signalize that a TAG has been read.
                            Values are 0,1,2,4 Hz

                &#39;time&#39;:int, Defines the holding time of the traffic lights. Values are from 0 - 255 seconds
            }

            buzzer:bool, If True buzzer will be active for 1sec when tag is detected.

            Note:
                1.) If ANY arguments are NONE then that argument will not be modified.
                2.) If ALL arguments are NONE then current configuration is returned.

        Returns:
            True: If configuration is set.

            current_config: dict
            {
                &#39;idle&#39;:str,
                &#39;tag&#39;:str,
                &#39;flash&#39;:int,
                &#39;time&#39;:int,
                buzzer:bool,
            }
        &#34;&#34;&#34;

        if traffic and not isinstance(traffic, dict):
            raise ValueError(&#34;dict type expected&#34;)

        if buzzer and not isinstance(buzzer, bool):
            raise ValueError(&#34;bool type expected&#34;)

        cfgData = self.read_config(8)
        if cfgData is None:
            return False

        if not traffic and not buzzer:
            value = cfgData[0] &amp; 0x03
            if value == 0x03:
                idle = &#34;blue&#34;
            elif value == 0x02:
                idle = &#34;red&#34;
            elif value == 0x01:
                idle = &#34;green&#34;
            else:
                idle = &#34;off&#34;

            value = cfgData[1] &amp; 0x03
            if value == 0x03:
                tag = &#34;blue&#34;
            elif value == 0x02:
                tag = &#34;red&#34;
            elif value == 0x01:
                tag = &#34;green&#34;
            else:
                tag = &#34;off&#34;

            value = (cfgData[1] &gt;&gt; 2) &amp; 0x03
            if value == 0x03:
                flash = 1
            elif value == 0x02:
                flash = 2
            elif value == 0x01:
                flash = 4
            else:
                flash = 0

            return {
                &#34;idle&#34;: idle,
                &#34;tag&#34;: tag,
                &#34;flash&#34;: flash,
                &#34;time&#34;: cfgData[2],
                &#34;buzzer&#34;: bool(cfgData[4] &amp; 0x01),
            }

        if traffic:
            cfgData[0] = 0x00
            if traffic[&#34;idle&#34;] == &#34;green&#34;:
                cfgData[0] = 0x01
            elif traffic[&#34;idle&#34;] == &#34;red&#34;:
                cfgData[0] = 0x02
            elif traffic[&#34;idle&#34;] == &#34;blue&#34;:
                cfgData[0] = 0x03

            cfgData[1] = 0x00
            if traffic[&#34;tag&#34;] == &#34;green&#34;:
                cfgData[1] = 0x01
            elif traffic[&#34;tag&#34;] == &#34;red&#34;:
                cfgData[1] = 0x02
            elif traffic[&#34;tag&#34;] == &#34;blue&#34;:
                cfgData[1] = 0x03

            if traffic[&#34;flash&#34;] == 1:
                cfgData[1] += 0x04
            elif traffic[&#34;flash&#34;] == 2:
                cfgData[1] += 0x08
            elif traffic[&#34;flash&#34;] == 3:
                cfgData[1] += 0x0C

            cfgData[2] = traffic[&#34;time&#34;]

        if buzzer:
            cfgData[4] = 1 if buzzer is True else 0

        # write configs
        ret = self.write_config(8, cfgData)
        if ret is None:
            return False

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="itekfeig.LRU500i.ANTENNA_No1"><code class="name">var <span class="ident">ANTENNA_No1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.ANTENNA_No2"><code class="name">var <span class="ident">ANTENNA_No2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.ANTENNA_OFF"><code class="name">var <span class="ident">ANTENNA_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.INTERFACE_ETHERNET"><code class="name">var <span class="ident">INTERFACE_ETHERNET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.INTERFACE_SERIAL"><code class="name">var <span class="ident">INTERFACE_SERIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.MAX_ANTENNA"><code class="name">var <span class="ident">MAX_ANTENNA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.MODE_BRM"><code class="name">var <span class="ident">MODE_BRM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.MODE_HOST"><code class="name">var <span class="ident">MODE_HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.MODE_NOTIFICATION"><code class="name">var <span class="ident">MODE_NOTIFICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.MODE_SCAN"><code class="name">var <span class="ident">MODE_SCAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.POWER_FULL"><code class="name">var <span class="ident">POWER_FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.POWER_LOW"><code class="name">var <span class="ident">POWER_LOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.POWER_MEDIUM"><code class="name">var <span class="ident">POWER_MEDIUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.READER_NAME"><code class="name">var <span class="ident">READER_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.READER_TYPE"><code class="name">var <span class="ident">READER_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.RSSI_MAX"><code class="name">var <span class="ident">RSSI_MAX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.LRU500i.RSSI_MIN"><code class="name">var <span class="ident">RSSI_MIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="itekfeig.LRU500i.antenna_multiplexing"><code class="name flex">
<span>def <span class="ident">antenna_multiplexing</span></span>(<span>self, mux_enable=None, selected_antennas=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the multiplexing of antennas in Auto Read Modes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mux_enable</code></strong></dt>
<dd>bool, If True activates multiplexing</dd>
<dt><strong><code>selected_antennas</code></strong></dt>
<dd>dict, Antennas which are used for the internal multiplexing</dd>
</dl>
<p>{
'ant1': bool, If True antenna-1 is selected
'ant2': bool, If True antenna-2 is selected
}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>if antenna is configured</dd>
<dt><code>dict</code></dt>
<dd>current multiplex configuration</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError for incorrect data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_multiplexing(self, mux_enable=None, selected_antennas=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure the multiplexing of antennas in Auto Read Modes

    Args:
        mux_enable: bool, If True activates multiplexing

        selected_antennas: dict, Antennas which are used for the internal multiplexing
        {
            &#39;ant1&#39;: bool, If True antenna-1 is selected
            &#39;ant2&#39;: bool, If True antenna-2 is selected
        }

    Returns:
        bool: if antenna is configured
        dict: current multiplex configuration

    Raises:
        ValueError for incorrect data
    &#34;&#34;&#34;

    if mux_enable and not isinstance(mux_enable, bool):
        raise ValueError(&#34;bool type expected&#34;)

    if selected_antennas and not isinstance(selected_antennas, dict):
        raise ValueError(&#34;dict type expected&#34;)

    cfgData = self.read_config(15)
    if cfgData is None:
        return False

    if not mux_enable and not selected_antennas:
        # return current config
        return {
            &#34;mux_enable&#34;: bool(cfgData[0] &amp; 0x01),
            &#34;selected_antennas&#34;: {
                &#34;ant1&#34;: bool(cfgData[1] &amp; 0x08),
                &#34;ant2&#34;: bool(cfgData[1] &amp; 0x10),
            },
        }

    if mux_enable and mux_enable is True:
        cfgData[0] = 0x01

    if selected_antennas:
        cfgData[1] = 0x00
        if selected_antennas[&#34;ant1&#34;] is True:
            cfgData[1] += 0x08
        if selected_antennas[&#34;ant2&#34;] is True:
            cfgData[1] += 0x10

    # write configs
    ret = self.write_config(15, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.antenna_power"><code class="name flex">
<span>def <span class="ident">antenna_power</span></span>(<span>self, ant:Â int, pwr_in_milliwatts:Â intÂ =Â -1) â€‘>Â Union[bool,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna Power</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ant</code></strong></dt>
<dd>must be one of supported ANTENNA_No*</dd>
<dt><strong><code>pwr_in_milliwatts</code></strong></dt>
<dd>int, in milliwats</dd>
</dl>
<p>if -1 return current power</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if power is set in the reader</dd>
<dt><code>pwr_in_milliwatts</code></dt>
<dd>int</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Given power is always adjusted to nearest valid value.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_power(self, ant: int, pwr_in_milliwatts: int = -1) -&gt; Union[bool, int]:
    &#34;&#34;&#34;Change Antenna Power

    Args:
        ant: must be one of supported ANTENNA_No*
        pwr_in_milliwatts: int, in milliwats
        if -1 return current power

    Returns:
        bool: True, if power is set in the reader
        pwr_in_milliwatts: int

    Raises:
        ValueError

    .. note:: Given power is always adjusted to nearest valid value.
    &#34;&#34;&#34;
    if not (ant is self.ANTENNA_No1 or ant is self.ANTENNA_No2):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    # depending upon antenna read config
    if ant is self.ANTENNA_No1:
        cfg_page = 3
    else:
        cfg_page = 20

    # Get index of respective antenna
    index = 2  # Default to Antenna1
    if ant is self.ANTENNA_No2:
        index = 10

    # read current configuration
    cfgData = self.read_config(cfg_page)
    if cfgData is None:
        return False

    if pwr_in_milliwatts == -1:
        return ANTENNA_POWER[cfgData[index]]

    # check antenna power
    # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
    if pwr_in_milliwatts &lt; 200:
        pwr = ANTENNA_POWER_REVERSE[100]
    elif 200 &lt;= pwr_in_milliwatts &lt; 300:
        pwr = ANTENNA_POWER_REVERSE[200]
    elif 300 &lt;= pwr_in_milliwatts &lt; 400:
        pwr = ANTENNA_POWER_REVERSE[300]
    elif 400 &lt;= pwr_in_milliwatts &lt; 500:
        pwr = ANTENNA_POWER_REVERSE[400]
    elif 500 &lt;= pwr_in_milliwatts &lt; 600:
        pwr = ANTENNA_POWER_REVERSE[500]
    elif 600 &lt;= pwr_in_milliwatts &lt; 700:
        pwr = ANTENNA_POWER_REVERSE[600]
    elif 700 &lt;= pwr_in_milliwatts &lt; 800:
        pwr = ANTENNA_POWER_REVERSE[700]
    else:  # pwr_in_milliwatts &gt;= 800:
        pwr = ANTENNA_POWER_REVERSE[800]

    cfgData[index] = pwr

    ret = self.write_config(cfg_page, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.antenna_rssi"><code class="name flex">
<span>def <span class="ident">antenna_rssi</span></span>(<span>self, ant:Â int, rssi:Â int) â€‘>Â Union[bool,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna RSSI</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ant</code></strong></dt>
<dd>must be one of supported ANTENNA_No*</dd>
<dt><strong><code>rssi</code></strong></dt>
<dd>must be in range RSSI_MIN and RSSI_MAX</dd>
</dl>
<p>IF rssi == 0, then itis disabled</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if power is set in the reader</dd>
<dt><code>rssi</code></dt>
<dd>current rssi value</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_rssi(self, ant: int, rssi: int) -&gt; Union[bool, int]:
    &#34;&#34;&#34;Change Antenna RSSI
    Args:
        ant: must be one of supported ANTENNA_No*
        rssi: must be in range RSSI_MIN and RSSI_MAX
        IF rssi == 0, then itis disabled

    Returns:
        bool: True, if power is set in the reader
        rssi: current rssi value

    Raises:
        ValueError
    &#34;&#34;&#34;
    if not (ant is self.ANTENNA_No1 or ant is self.ANTENNA_No2):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
        raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

    cfgData = self.read_config(20)
    if cfgData is None:
        return False

    # update rssi
    if ant is self.ANTENNA_No1:
        cfgData[0] = rssi

    elif ant is self.ANTENNA_No2:
        cfgData[1] = rssi

    ret = self.write_config(20, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.change_mode"><code class="name flex">
<span>def <span class="ident">change_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Reader mode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>one of the supporeted operating mode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Call get_last_error() for more reason</dd>
<dt><code>bool</code></dt>
<dd>If True, new mode is set in the reader</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode(self, mode):
    &#34;&#34;&#34;Change Reader mode

    Args:
        mode: one of the supporeted operating mode

    Returns:
        None: Call get_last_error() for more reason
        bool: If True, new mode is set in the reader
    &#34;&#34;&#34;
    cfgData = self.read_config(1)
    if cfgData is None:
        return False

    if cfgData[13] == mode:  # Current Mode is same
        FeigBase._last_error = FeigError.MODE_SAME
        return False

    # update mode
    cfgData[13] = mode

    ret = self.write_config(1, cfgData)
    if ret is None:
        return False

    FeigBase._current_mode = mode

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, interface, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the reader using one of its interface with given settings.
Onece the connection is established, a complete aconfiguration is read
from the reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong></dt>
<dd>one of the supported interface</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>of selected interface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection is sccessfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, interface, settings):
    &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
    Onece the connection is established, a complete aconfiguration is read
    from the reader.

    Args:
        interface: one of the supported interface
        settings: of selected interface

    Returns:
        bool: True if connection is sccessfull
    &#34;&#34;&#34;
    if interface == self.INTERFACE_SERIAL:
        from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
        from ..interface.feig_serial import FeigSerial

        if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
            parity = PARITY_NONE
        elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
            parity = PARITY_EVEN
        elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
            parity = PARITY_ODD
        else:
            raise ValueError(&#34;NotSupported:Parity&#34;)

        FeigBase._interface = FeigSerial()
        FeigBase._interface.open(settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity)

    elif interface == self.INTERFACE_ETHERNET:
        from ..interface.feig_ethernet import FeigEthernet

        FeigBase._interface = FeigEthernet()
        FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])

    else:
        raise ValueError(&#34;NotSupported:Interface&#34;)

    if FeigBase._interface.error != FeigError.OK:
        FeigBase._last_error = FeigBase._interface.error
        return False

    # Forced: Antenna OFF, if tags are present in the feild
    # connection to reader takes time or fail
    self.rf_onoff(self.ANTENNA_OFF)

    time.sleep(0.1)

    # Get reader type
    ret = self._get_reader_type()
    if not ret:
        logger.error(&#34;Failed to get reader ID&#34;)
        return False

    if ret != self.READER_TYPE:
        FeigBase._last_error = FeigError.INVALID_READER
        FeigBase._interface.close()
        FeigBase._interface = None
        err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
        logger.error(err_msg)
        return False

    # Get ALL INFO from the reader
    self.get_reader_info()

    time.sleep(0.1)

    # Get ALL CONFIGURATION from reader memory
    ret = self.read_all_config()
    if ret is None:
        return False

    time.sleep(0.1)

    # Configure operating modes
    from ..common.feig_host import FeigHost

    self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

    from ..common.feig_buffer_read import FeigBufferRead

    self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

    if interface == self.INTERFACE_SERIAL:
        from ..common.feig_scan import FeigScan

        self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)
    elif interface == self.INTERFACE_ETHERNET:
        from ..common.feig_notification import FeigNotification

        self.NotificationMode = FeigNotification(
            FeigBase._interface, FeigBase._last_error
        )

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.device_id"><code class="name flex">
<span>def <span class="ident">device_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns reader device ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_id(self) -&gt; str:
    &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
    return deepcopy(self._reader_info[&#34;DeviceID&#34;])</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.diagnostic"><code class="name flex">
<span>def <span class="ident">diagnostic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform reader diagnostic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostic(self):
    &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6E:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return self._diagnostic_parser(data[2:])</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from current reader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
    if FeigBase._interface:
        FeigBase._interface.close()</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get reader INPUT pin status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(self):
    &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x74:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            in1 = data[2] &amp; 0x01
            in2 = (data[2] &gt;&gt; 1) &amp; 0x01
            return in1, in2</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.get_reader_info"><code class="name flex">
<span>def <span class="ident">get_reader_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get complete reader information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reader_info(self):
    &#34;&#34;&#34;Get complete reader information

    &#34;&#34;&#34;
    if len(self._reader_info) == 0:

        for mode in READER_INFO_MODE_LIST:
            cmd = [0x66, mode]
            data = FeigBase._interface.transfer(1.0, cmd)
            if data is None:
                FeigBase._last_error = FeigError.COMM_TIMEOUT
                return

            FeigBase._last_error = FeigError.INVALID_RESPONSE
            if data[0] == 0x66:
                FeigBase._last_error = self._feig_status_parser(data[1])
                if FeigBase._last_error is FeigError.OK:
                    self._reader_info_parser(mode, data[2:])

    return deepcopy(self._reader_info)</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.notification_channel"><code class="name flex">
<span>def <span class="ident">notification_channel</span></span>(<span>self, ackData=None, dstHost=None, keepAlive=None, holdTime=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure Notification channel of the reader</p>
<h2 id="args">Args</h2>
<p>ackData:bool,
True = Acknowledge Notification Data</p>
<p>dstHost:tuple, (dstIP,dstPort)
dstIP: str, Destination IPv4
dstIP: str/int, Destination PORT from 0 - 65535</p>
<p>keepAlive:tuple, (enable, time)
enable: bool, True to enable keep alive message
time: int, keep alive message time from 0 - 65535 secs</p>
<p>holdTime:int, Defines the connection hold time from 0 - 255 sec</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>currentConfig</code></dt>
<dd>dict, If no argument is passed return current config
{
'ackData': None,
'dstHost': None,
'keepAlive': None
}</dd>
<dt><code>status</code></dt>
<dd>bool, True if configuration set successfully</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notification_channel(self, ackData=None, dstHost=None, keepAlive=None, holdTime=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure Notification channel of the reader

    Args:
        ackData:bool,
            True = Acknowledge Notification Data

        dstHost:tuple, (dstIP,dstPort)
            dstIP: str, Destination IPv4
            dstIP: str/int, Destination PORT from 0 - 65535

        keepAlive:tuple, (enable, time)
            enable: bool, True to enable keep alive message
            time: int, keep alive message time from 0 - 65535 secs

        holdTime:int, Defines the connection hold time from 0 - 255 sec

    Returns:
        currentConfig: dict, If no argument is passed return current config
            {
                &#39;ackData&#39;: None,
                &#39;dstHost&#39;: None,
                &#39;keepAlive&#39;: None
            }

        status: bool, True if configuration set successfully
    &#34;&#34;&#34;

    # check argument
    if ackData and not isinstance(ackData, bool):
        raise TypeError(&#34;bool type expected&#34;)

    if dstHost and not isinstance(dstHost, tuple):
        raise TypeError(&#34;tuple type expected&#34;)

    if keepAlive and not isinstance(keepAlive, tuple):
        raise TypeError(&#34;tuple type expected&#34;)

    if holdTime and not isinstance(holdTime, int):
        raise TypeError(&#34;int type expected&#34;)

    cfgData = self.read_config(49)
    if cfgData is None:
        return False

    if not ackData and not dstHost and not keepAlive:
        # return dictionary
        ackData = bool(cfgData[0] &amp; 0x80)

        dstIp = (cfgData[7] &lt;&lt; 24)
        dstIp += (cfgData[8] &lt;&lt; 16)
        dstIp += (cfgData[9] &lt;&lt; 8)
        dstIp += cfgData[10]

        dstIp = str(ipaddress.ip_address(dstIp))
        dstPort = cfgData[11] * 256 + cfgData[12]

        keepen = bool(cfgData[4] &amp; 0x01)
        keeptime = cfgData[5] * 256 + cfgData[6]

        holdTime = cfgData[13]

        return {
            &#34;ackData&#34;: ackData,
            &#34;dstHost&#34;: (dstIp, dstPort),
            &#34;keepAlive&#34;: (keepen, keeptime),
            &#34;holdTime&#34;: holdTime,
        }

    # set ack
    if ackData:
        if ackData is True:
            cfgData[0] = 0x80
        else:
            cfgData[0] = 0x00

    # keep alive
    if keepAlive:
        if keepAlive[0] is True:
            cfgData[4] = 0x01
        else:
            cfgData[4] = 0x00
        if keepAlive[1] &gt; 65535:
            raise ValueError(&#34;keepAlive time exceeds range&#34;)
        cfgData[5] = (keepAlive[1] &gt;&gt; 8) &amp; 255
        cfgData[6] = (keepAlive[1] &gt;&gt; 0) &amp; 255

    # destintation
    if dstHost:
        try:
            ipaddr = dstHost[0]
            ipaddr = int(ipaddress.ip_address(ipaddr))
            ipaddr = ipaddress.v4_int_to_packed(ipaddr)
            iperr = False
        except ipaddress.AddressValueError:
            iperr = True
        if iperr is True:
            raise ValueError(&#34;dst IP incorrect&#34;)
        cfgData[7] = ipaddr[0]
        cfgData[8] = ipaddr[1]
        cfgData[9] = ipaddr[2]
        cfgData[10] = ipaddr[3]

        if dstHost[1] &gt; 65535:
            raise ValueError(&#34;dst Port excceds range&#34;)
        cfgData[11] = (dstHost[1] &gt;&gt; 8) &amp; 255
        cfgData[12] = (dstHost[1] &gt;&gt; 0) &amp; 255

    # hold time
    if holdTime:
        if holdTime &gt; 255:
            raise ValueError(&#34;holdTime exceeds range&#34;)
        cfgData[13] = holdTime

    # write configs
    ret = self.write_config(49, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.read_mode_data"><code class="name flex">
<span>def <span class="ident">read_mode_data</span></span>(<span>self, flags=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure READ MODE data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flags</code></strong></dt>
<dd>dict, All parameters are MANDATORY</dd>
</dl>
<p>{
'uid': bool, If True reader will send IDD(EPC or EPC+TID)
'lsb': bool, If True byte order of frame will be LSB else MSB
'time': bool, If True reader will send its time
'date': bool, If True reader will send its date
'input': bool, If True reader will send its INPUT status
'mac': bool, If True reader will send its MAC address
'input': bool, If True reader will send its INPUT status</p>
<pre><code>'antno': bool, If True reader will send Antenna number
'antext': bool, If True reader will send antenna rssi, phase angle
'antstore': bool, If True reader will collect transponder data from all antennas in one data record

'readall': bool, If True reader will read complete BANK data
'bank': int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

'db': bool, If True reader will send DATA BLOCKs
'dbaddr': int, Address of first data blocks from 0 to 65535
'dbn': int, Number of data blocks from 0 to 65535
</code></pre>
<p>}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>flags</code></dt>
<dd>dict , If no argument is passed current settings is send as per above flags definitions</dd>
<dt><code>True</code></dt>
<dd>If write opertaion is successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_data(self, flags=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure READ MODE data

    Args:
        flags: dict, All parameters are MANDATORY
        {
            &#39;uid&#39;: bool, If True reader will send IDD(EPC or EPC+TID)
            &#39;lsb&#39;: bool, If True byte order of frame will be LSB else MSB
            &#39;time&#39;: bool, If True reader will send its time
            &#39;date&#39;: bool, If True reader will send its date
            &#39;input&#39;: bool, If True reader will send its INPUT status
            &#39;mac&#39;: bool, If True reader will send its MAC address
            &#39;input&#39;: bool, If True reader will send its INPUT status

            &#39;antno&#39;: bool, If True reader will send Antenna number
            &#39;antext&#39;: bool, If True reader will send antenna rssi, phase angle
            &#39;antstore&#39;: bool, If True reader will collect transponder data from all antennas in one data record

            &#39;readall&#39;: bool, If True reader will read complete BANK data
            &#39;bank&#39;: int, One of BANK_EPC, BANK_TID, BANK_USER banks from which data is to be read.

            &#39;db&#39;: bool, If True reader will send DATA BLOCKs
            &#39;dbaddr&#39;: int, Address of first data blocks from 0 to 65535
            &#39;dbn&#39;: int, Number of data blocks from 0 to 65535
        }

    Returns:
        flags: dict , If no argument is passed current settings is send as per above flags definitions
        True: If write opertaion is successfull

    &#34;&#34;&#34;

    if flags and not isinstance(flags, dict):
        raise TypeError(&#34;dict type expected&#34;)

    cfgData = self.read_config(11)
    if cfgData is None:
        return False

    if not flags:
        # return flags
        if cfgData[3] == self.BANK_EPC:
            bank = self.BANK_EPC
        elif cfgData[3] == self.BANK_TID:
            bank = self.BANK_TID
        elif cfgData[3] == self.BANK_USER:
            bank = self.BANK_USER
        else:
            bank = -1

        dbaddr = cfgData[4] * 256 + cfgData[5]
        dbn = cfgData[8] * 256 + cfgData[9]

        return {
            &#34;uid&#34;: bool(cfgData[0] &amp; 0x01),
            &#34;db&#34;: bool(cfgData[0] &amp; 0x02),
            &#34;lsb&#34;: bool(cfgData[0] &amp; 0x08),
            &#34;antno&#34;: bool(cfgData[0] &amp; 0x10),
            &#34;time&#34;: bool(cfgData[0] &amp; 0x20),
            &#34;date&#34;: bool(cfgData[0] &amp; 0x40),
            &#34;input&#34;: bool(cfgData[1] &amp; 0x01),
            &#34;mac&#34;: bool(cfgData[1] &amp; 0x02),
            &#34;antext&#34;: bool(cfgData[1] &amp; 0x10),
            &#34;antstore&#34;: bool(cfgData[2] &amp; 0x02),
            &#34;readall&#34;: bool(cfgData[2] &amp; 0x08),
            &#34;bank&#34;: bank,
            &#34;dbaddr&#34;: dbaddr,
            &#34;dbn&#34;: dbn,
        }

    try:
        trdata1 = 0
        if flags[&#34;uid&#34;] is True:
            trdata1 += 0x01
        if flags[&#34;db&#34;] is True:
            trdata1 += 0x02
        if flags[&#34;lsb&#34;] is True:
            trdata1 += 0x08
        if flags[&#34;time&#34;] is True:
            trdata1 += 0x20
        if flags[&#34;date&#34;] is True:
            trdata1 += 0x40

        trdata2 = 0
        if flags[&#34;input&#34;] is True:
            trdata2 += 0x01
        if flags[&#34;mac&#34;] is True:
            trdata2 += 0x02
        if flags[&#34;antext&#34;] is True:
            trdata2 += 0x10
            trdata1 += 0x80
        else:
            if flags[&#34;antno&#34;] is True:
                trdata1 += 0x10

        trdata3 = 0
        if flags[&#34;antstore&#34;] is True:
            trdata3 += 0x02
        if flags[&#34;readall&#34;] is True:
            trdata3 += 0x08

        cfgData[0] = trdata1
        cfgData[1] = trdata2
        cfgData[2] = trdata3
        cfgData[3] = flags[&#34;bank&#34;]
        cfgData[4] = (flags[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[5] = (flags[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
        cfgData[8] = (flags[&#34;dbn&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[9] = (flags[&#34;dbn&#34;] &gt;&gt; 0) &amp; 0xFF

    except KeyError:
        raise ValueError(&#34;Invalid arguments&#34;)

    # write configs
    ret = self.write_config(11, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.read_mode_filter"><code class="name flex">
<span>def <span class="ident">read_mode_filter</span></span>(<span>self, transpondervalidtime=None, trid=None, inevflt=None) â€‘>Â Union[bool,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure READ MODE Filter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transpondervalidtime</code></strong></dt>
<dd>int, This the time during which a transponder will not be reported a second time,
range is from 0 - 65535 (x100msec)</dd>
<dt><strong><code>trid</code></strong></dt>
<dd>dict, Sets the data source for transponder identification</dd>
</dl>
<p>{
'source': int, values are 0=DataBlock ; 1=SerialNumber
'dbaddr': int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
'dbn': int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
}</p>
<dl>
<dt><strong><code>inevflt</code></strong></dt>
<dd>dict,</dd>
</dl>
<p>{
'input1': bool, If True input event on input-1 will be notified
'input2': bool, If True input event on input-2 will be notified
'timeout': bool, If True timeout event during active BRM or Notification Mode will be notified
'trig': bool, If True change of the BRM or Notification Mode status will be notified
}</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>dict, current cconfiguration</dd>
</dl>
<p>{
'transpondervalidtime': int,
'trid': {
'source': int,
'dbaddr': int,
'dbn': int,
},
'inevflt':{
'input1': bool,
'input2': bool,
'timeout': bool,
'trig': bool,
}
}</p>
<dl>
<dt><code>True</code></dt>
<dd>If write successfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None) -&gt; Union[bool, dict]:
    &#34;&#34;&#34;Configure READ MODE Filter

    Args:
        transpondervalidtime: int, This the time during which a transponder will not be reported a second time,
                                    range is from 0 - 65535 (x100msec)

        trid: dict, Sets the data source for transponder identification
        {
            &#39;source&#39;: int, values are 0=DataBlock ; 1=SerialNumber
            &#39;dbaddr&#39;: int, Set start address of data block, range(0 - 65535). Ignored for SerialNumber.
            &#39;dbn&#39;: int, Set start address of data block, range(0 - 255). Ignored for SerialNumber.
        }

        inevflt: dict,
        {
            &#39;input1&#39;: bool, If True input event on input-1 will be notified
            &#39;input2&#39;: bool, If True input event on input-2 will be notified
            &#39;timeout&#39;: bool, If True timeout event during active BRM or Notification Mode will be notified
            &#39;trig&#39;: bool, If True change of the BRM or Notification Mode status will be notified
        }

    Returns:
        data: dict, current cconfiguration
        {
            &#39;transpondervalidtime&#39;: int,
            &#39;trid&#39;: {
                &#39;source&#39;: int,
                &#39;dbaddr&#39;: int,
                &#39;dbn&#39;: int,
            },
            &#39;inevflt&#39;:{
                &#39;input1&#39;: bool,
                &#39;input2&#39;: bool,
                &#39;timeout&#39;: bool,
                &#39;trig&#39;: bool,
            }
        }

        True: If write successfull
    &#34;&#34;&#34;

    if transpondervalidtime and not isinstance(transpondervalidtime, int):
        raise TypeError(&#34;int type expected&#34;)

    if trid and not isinstance(trid, dict):
        raise TypeError(&#34;dict type expected&#34;)

    if inevflt and not isinstance(inevflt, int):
        raise TypeError(&#34;dict type expected&#34;)

    cfgData = self.read_config(12)
    if cfgData is None:
        return False

    if not transpondervalidtime and not trid and not inevflt:
        # return current config
        return {
            &#34;transpondervalidtime&#34;: cfgData[0] * 256 + cfgData[1],
            &#34;trid&#34;: {
                &#34;source&#34;: 1 if (cfgData[2] &amp; 0x02) else 0,
                &#34;dbaddr&#34;: cfgData[3] * 256 + cfgData[4],
                &#34;dbn&#34;: cfgData[5],
            },
            &#34;inevflt&#34;: {
                &#34;input1&#34;: bool(cfgData[6] &amp; 0x01),
                &#34;input2&#34;: bool(cfgData[6] &amp; 0x02),
                &#34;timeout&#34;: bool(cfgData[7] &amp; 0x02),
                &#34;trig&#34;: bool(cfgData[7] &amp; 0x01),
            },
        }

    if transpondervalidtime:
        cfgData[0] = (transpondervalidtime &gt;&gt; 8) &amp; 0xFF
        cfgData[1] = (transpondervalidtime &gt;&gt; 0) &amp; 0xFF

    if trid:
        cfgData[2] = trid[&#34;source&#34;]
        cfgData[3] = (trid[&#34;dbaddr&#34;] &gt;&gt; 8) &amp; 0xFF
        cfgData[4] = (trid[&#34;dbaddr&#34;] &gt;&gt; 0) &amp; 0xFF
        cfgData[5] = trid[&#34;dbn&#34;]

    if inevflt:
        cfgData[6] = 0
        if inevflt[&#34;input1&#34;] is True:
            cfgData[6] += 0x01
        if inevflt[&#34;input2&#34;] is True:
            cfgData[6] += 0x02

        cfgData[7] = 0
        if inevflt[&#34;timeout&#34;] is True:
            cfgData[7] += 0x02
        if inevflt[&#34;trig&#34;] is True:
            cfgData[7] += 0x01

    # write configs
    ret = self.write_config(12, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.rf_onoff"><code class="name flex">
<span>def <span class="ident">rf_onoff</span></span>(<span>self, antno, maintainhost=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn ON/OFF individual antenna</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rf_onoff(self, antno, maintainhost=False):
    &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
    rf_output = 0
    if maintainhost is True:
        rf_output += 0x80
    rf_output += antno

    cmd = [0x6A, rf_output]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6A:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, out_rec:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set/Configure Digital Output or Relay pins</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>out_rec</code></strong></dt>
<dd>key,value as per following format
{
'type': str, 'digital' or 'relay',
'pin': int,
'mode': 'on' or 'off' or 'flash',
'freq': int, 1,2,4,8 Hz
'time': int, 1 to 65535 delay corresponds to multiple of 100milli
}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, out_rec: dict):
    &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

    Args:
        out_rec: key,value as per following format
            {
                &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                &#39;pin&#39;: int,
                &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                &#39;freq&#39;: int, 1,2,4,8 Hz
                &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
            }
    &#34;&#34;&#34;
    if out_rec[&#34;type&#34;] == &#34;digital&#34;:
        out_type = 0x00
    elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
        out_type = 0x80
    else:
        raise ValueError(&#34;Invalid Value&#34;)
    out_type = 0x80 + out_rec[&#34;pin&#34;]

    if out_rec[&#34;mode&#34;] == &#34;on&#34;:
        out_state = 0x01
    elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
        out_state = 0x02
    elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
        out_state = 0x03
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;freq&#34;] == 1:
        out_state += 0x03 * 4
    elif out_rec[&#34;freq&#34;] == 2:
        out_state += 0x02 * 4
    elif out_rec[&#34;freq&#34;] == 4:
        out_state += 0x01 * 4
    elif out_rec[&#34;freq&#34;] == 8:
        out_state += 0x00 * 4
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
        raise ValueError(&#34;Invalid Value&#34;)
    out_time = out_rec[&#34;time&#34;]

    cmd = [
        0x72,
        0x01,
        0x01,
        out_type,
        out_state,
        (out_time &gt;&gt; 8) &amp; 0xFF,
        (out_time &gt;&gt; 0) &amp; 0xFF,
    ]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x72:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.signaler"><code class="name flex">
<span>def <span class="ident">signaler</span></span>(<span>self, traffic:Â dictÂ =Â None, buzzer:Â boolÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function configures in-built TrafficLight, Buzzer of the reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>traffic</code></strong></dt>
<dd>dict,</dd>
</dl>
<p>{
'idle':str, Defines the status of the traffic lights during the idle mode.
Values are 'off','red','green','blue'</p>
<pre><code>'tag':str, Defines the color the reader uses to signalize that a transponder has been read.
            Values are 'off','red','green','blue'

'flash':int, Defines the flashing frequency the reader uses to signalize that a TAG has been read.
            Values are 0,1,2,4 Hz

'time':int, Defines the holding time of the traffic lights. Values are from 0 - 255 seconds
</code></pre>
<p>}</p>
<p>buzzer:bool, If True buzzer will be active for 1sec when tag is detected.</p>
<p>Note:
1.) If ANY arguments are NONE then that argument will not be modified.
2.) If ALL arguments are NONE then current configuration is returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code></dt>
<dd>If configuration is set.</dd>
<dt><code>current_config</code></dt>
<dd>dict</dd>
</dl>
<p>{
'idle':str,
'tag':str,
'flash':int,
'time':int,
buzzer:bool,
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signaler(self, traffic: dict = None, buzzer: bool = None):
    &#34;&#34;&#34;This function configures in-built TrafficLight, Buzzer of the reader.

    Args:
        traffic: dict,
        {
            &#39;idle&#39;:str, Defines the status of the traffic lights during the idle mode.
                        Values are &#39;off&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;

            &#39;tag&#39;:str, Defines the color the reader uses to signalize that a transponder has been read.
                        Values are &#39;off&#39;,&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;

            &#39;flash&#39;:int, Defines the flashing frequency the reader uses to signalize that a TAG has been read.
                        Values are 0,1,2,4 Hz

            &#39;time&#39;:int, Defines the holding time of the traffic lights. Values are from 0 - 255 seconds
        }

        buzzer:bool, If True buzzer will be active for 1sec when tag is detected.

        Note:
            1.) If ANY arguments are NONE then that argument will not be modified.
            2.) If ALL arguments are NONE then current configuration is returned.

    Returns:
        True: If configuration is set.

        current_config: dict
        {
            &#39;idle&#39;:str,
            &#39;tag&#39;:str,
            &#39;flash&#39;:int,
            &#39;time&#39;:int,
            buzzer:bool,
        }
    &#34;&#34;&#34;

    if traffic and not isinstance(traffic, dict):
        raise ValueError(&#34;dict type expected&#34;)

    if buzzer and not isinstance(buzzer, bool):
        raise ValueError(&#34;bool type expected&#34;)

    cfgData = self.read_config(8)
    if cfgData is None:
        return False

    if not traffic and not buzzer:
        value = cfgData[0] &amp; 0x03
        if value == 0x03:
            idle = &#34;blue&#34;
        elif value == 0x02:
            idle = &#34;red&#34;
        elif value == 0x01:
            idle = &#34;green&#34;
        else:
            idle = &#34;off&#34;

        value = cfgData[1] &amp; 0x03
        if value == 0x03:
            tag = &#34;blue&#34;
        elif value == 0x02:
            tag = &#34;red&#34;
        elif value == 0x01:
            tag = &#34;green&#34;
        else:
            tag = &#34;off&#34;

        value = (cfgData[1] &gt;&gt; 2) &amp; 0x03
        if value == 0x03:
            flash = 1
        elif value == 0x02:
            flash = 2
        elif value == 0x01:
            flash = 4
        else:
            flash = 0

        return {
            &#34;idle&#34;: idle,
            &#34;tag&#34;: tag,
            &#34;flash&#34;: flash,
            &#34;time&#34;: cfgData[2],
            &#34;buzzer&#34;: bool(cfgData[4] &amp; 0x01),
        }

    if traffic:
        cfgData[0] = 0x00
        if traffic[&#34;idle&#34;] == &#34;green&#34;:
            cfgData[0] = 0x01
        elif traffic[&#34;idle&#34;] == &#34;red&#34;:
            cfgData[0] = 0x02
        elif traffic[&#34;idle&#34;] == &#34;blue&#34;:
            cfgData[0] = 0x03

        cfgData[1] = 0x00
        if traffic[&#34;tag&#34;] == &#34;green&#34;:
            cfgData[1] = 0x01
        elif traffic[&#34;tag&#34;] == &#34;red&#34;:
            cfgData[1] = 0x02
        elif traffic[&#34;tag&#34;] == &#34;blue&#34;:
            cfgData[1] = 0x03

        if traffic[&#34;flash&#34;] == 1:
            cfgData[1] += 0x04
        elif traffic[&#34;flash&#34;] == 2:
            cfgData[1] += 0x08
        elif traffic[&#34;flash&#34;] == 3:
            cfgData[1] += 0x0C

        cfgData[2] = traffic[&#34;time&#34;]

    if buzzer:
        cfgData[4] = 1 if buzzer is True else 0

    # write configs
    ret = self.write_config(8, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.LRU500i.system_date_time"><code class="name flex">
<span>def <span class="ident">system_date_time</span></span>(<span>self, date_value=None, timer_value=None) â€‘>Â Union[bool,Â tuple]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_date_time(self, date_value=None, timer_value=None) -&gt; Union[bool, tuple]:
    if date_value is None and timer_value is None:
        # get
        cmd = [0x88]
    else:
        # set
        if not isinstance(date_value, tuple):
            raise ValueError(&#34;Invalid Argument:{}&#34;.format(date_value))
        if not isinstance(timer_value, tuple):
            raise ValueError(&#34;Invalid Argument:{}&#34;.format(timer_value))

        century = date_value[0]
        year = date_value[1]
        month = date_value[2]
        day = date_value[3]
        timezone = date_value[4]
        if (
            (century &gt; 99) or (year &gt; 99)
            or ((month &lt; 1) or (month &gt; 12))
            or ((day &lt; 1) or (day &gt; 31))
            or (timezone &gt; 23)
        ):
            raise ValueError(&#34;Invalid range&#34;)

        hour = timer_value[0]
        minutes = timer_value[1]
        milli = timer_value[2]
        if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
            raise ValueError(&#34;Invalid range&#34;)

        cmd = [
            0x87,
            century,
            year,
            month,
            day,
            timezone,
            hour,
            minutes,
            (milli &gt;&gt; 8) &amp; 0xFF,
            (milli &gt;&gt; 0) &amp; 0xFF,
        ]

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return False

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x87:  # Set
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    elif data[0] == 0x88:  # Get
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return (
                (data[2], data[3], data[4], data[5], data[6]),
                (data[7], data[8], (data[9] * 256 + data[10])),
            )

    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></b></code>:
<ul class="hlist">
<li><code><a title="itekfeig.common.feig_base.FeigBase.add_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.add_filter">add_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error">get_last_error</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error_str" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error_str">get_last_error_str</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_software_version" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_software_version">get_software_version</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.login" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.login">login</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_all_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_all_config">read_all_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_config">read_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.remove_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.remove_filter">remove_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.reset_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.reset_config">reset_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_controller_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_controller_reset">rf_controller_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_reset">rf_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.system_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.system_reset">system_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.write_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.write_config">write_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="itekfeig.MRU102"><code class="flex name class">
<span>class <span class="ident">MRU102</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all readers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MRU102(FeigBase):
    # Reader Type, use this to match after connection
    READER_NAME = &#34;MRU102&#34;
    READER_TYPE = FEIG_READER_IDS[READER_NAME]

    INTERFACE_SERIAL = 0
    INTERFACE_ETHERNET = 1

    MODE_HOST = 0x00
    MODE_SCAN = 0x01
    MODE_BRM = 0x80
    MODE_NOTIFICATION = 0xC0

    ANTENNA_OFF = 0x00
    ANTENNA_No1 = 0x01
    ANTENNA_No2 = 0x02
    ANTENNA_No3 = 0x03
    ANTENNA_Internal = 0x04

    MAX_ANTENNA = 4

    POWER_LOW = 50
    POWER_MEDIUM = 300
    POWER_FULL = 500

    RSSI_MIN = 0
    RSSI_MAX = 255

    def __init__(self):
        super().__init__()
        self._reader_info = {}
        self._device_id = None

    ####################################################################################
    ####    READER CONNECTION API
    ####################################################################################

    def connect(self, interface, settings):
        &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
        Onece the connection is established, a complete aconfiguration is read
        from the reader.

        Args:
            interface: one of the supported interface
            settings: of selected interface

        Returns:
            bool: True if connection is sccessfull
        &#34;&#34;&#34;

        # Configure interface
        if interface == self.INTERFACE_SERIAL:
            from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
            from ..interface.feig_serial import FeigSerial

            if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
                parity = PARITY_NONE
            elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
                parity = PARITY_EVEN
            elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
                parity = PARITY_ODD
            else:
                raise ValueError(&#34;NotSupported:Parity&#34;)

            FeigBase._interface = FeigSerial()
            opened = FeigBase._interface.open(
                settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity
            )
            if opened is False:
                FeigBase._last_error = FeigError.SERIAL
                err_msg = &#34;Failed to connect to {} {}&#34;.format(
                    settings[&#34;PORT&#34;], FeigBase._interface.error
                )
                logger.error(err_msg)
                return False

        elif interface == self.INTERFACE_ETHERNET:
            from ..interface.feig_ethernet import FeigEthernet

            FeigBase._interface = FeigEthernet()
            opened = FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])
            if opened is False:
                FeigBase._last_error = FeigError.ETHERNET
                return False
        else:
            raise ValueError(&#34;NotSupported:Interface&#34;)

        if FeigBase._interface.error != FeigError.OK:
            FeigBase._last_error = FeigBase._interface.error
            return False

        # Forced: Antenna OFF, if tags are present in the feild
        # connection to reader takes time or fail
        self.rf_onoff(self.ANTENNA_OFF)

        time.sleep(0.1)

        # Get reader type
        ret = self._get_reader_type()
        if not ret:
            logger.error(&#34;Failed to get reader ID&#34;)
            return False

        if ret != self.READER_TYPE:
            FeigBase._last_error = FeigError.INVALID_READER
            FeigBase._interface.close()
            FeigBase._interface = None
            err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
            logger.error(err_msg)
            return False

        # Get ALL INFO from the reader
        self.get_reader_info()

        # Get ALL CONFIGURATION from reader memory
        ret = self.read_all_config()
        if ret is None:
            return False

        time.sleep(0.1)

        # Configure operating modes
        from ..common.feig_host import FeigHost

        self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

        from ..common.feig_buffer_read import FeigBufferRead

        self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

        if interface == self.INTERFACE_SERIAL:
            from ..common.feig_scan import FeigScan

            self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)
        elif interface == self.INTERFACE_ETHERNET:
            from ..common.feig_notification import FeigNotification

            self.NotificationMode = FeigNotification(
                FeigBase._interface, FeigBase._last_error
            )

        return True

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
        if FeigBase._interface:
            FeigBase._interface.close()

    ####################################################################################
    ####    READER CONTROL API
    ####################################################################################

    def rf_onoff(self, antno, maintainhost=False):
        &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
        rf_output = 0
        if maintainhost is True:
            rf_output += 0x80
        rf_output += antno

        cmd = [0x6A, rf_output]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6A:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        return False

    def set_output(self, out_rec: dict):
        &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

        Args:
            out_rec: key,value as per following format
                {
                    &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                    &#39;pin&#39;: int,
                    &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                    &#39;freq&#39;: int, 1,2,4,8 Hz
                    &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
                }
        &#34;&#34;&#34;
        if out_rec[&#34;type&#34;] == &#34;digital&#34;:
            out_type = 0x00
        elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
            out_type = 0x80
        else:
            raise ValueError(&#34;Invalid Value&#34;)
        out_type = 0x80 + out_rec[&#34;pin&#34;]

        if out_rec[&#34;mode&#34;] == &#34;on&#34;:
            out_state = 0x01
        elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
            out_state = 0x02
        elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
            out_state = 0x03
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;freq&#34;] == 1:
            out_state += 0x03 * 4
        elif out_rec[&#34;freq&#34;] == 2:
            out_state += 0x02 * 4
        elif out_rec[&#34;freq&#34;] == 4:
            out_state += 0x01 * 4
        elif out_rec[&#34;freq&#34;] == 8:
            out_state += 0x00 * 4
        else:
            raise ValueError(&#34;Invalid Value&#34;)

        if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
            raise ValueError(&#34;Invalid Value&#34;)
        out_time = out_rec[&#34;time&#34;]

        cmd = [
            0x72,
            0x01,
            0x01,
            out_type,
            out_state,
            (out_time &gt;&gt; 8) &amp; 0xFF,
            (out_time &gt;&gt; 0) &amp; 0xFF,
        ]
        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x72:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

    def get_input(self):
        &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x74:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                in1 = data[2] &amp; 0x01
                in2 = (data[2] &gt;&gt; 1) &amp; 0x01
                return in1, in2

    def change_mode(self, mode):
        &#34;&#34;&#34;Change Reader mode

        Args:
            mode: one of the supporeted operating mode

        Returns:
            None: Call get_last_error() for more reason
            bool: If True, new mode is set in the reader
        &#34;&#34;&#34;
        cfgData = self.read_config(1)
        if cfgData is None:
            return False

        if cfgData[13] == mode:  # Current Mode is same
            FeigBase._last_error = FeigError.MODE_SAME
            return False

        # update mode
        cfgData[13] = mode

        ret = self.write_config(1, cfgData)
        if ret is None:
            return False

        FeigBase._current_mode = mode

        return True

    @staticmethod
    def _diagnostic_parser(data):

        def test_error(x) -&gt; str:
            if x: return &#34;FAIL&#34;
            return &#34;OK&#34;

        diag = {}
        data_set = data[0]
        offset = 1
        for _ in range(0, data_set):
            mode = data[offset]
            if mode == 0x04:
                # EEPROM
                eeprom = {}
                int_error = data[offset + 1] * 256 + data[offset + 2]

                eeprom[&#34;EE_DEV1&#34;] = test_error(int_error &amp; 0x0001)
                eeprom[&#34;RF_DECODER&#34;] = test_error(int_error &amp; 0x0008)
                eeprom[&#34;ParameterMismatch&#34;] = test_error(int_error &amp; 0x0010)
                eeprom[&#34;TEMP_WARN&#34;] = test_error(int_error &amp; 0x0020)
                eeprom[&#34;PeripheryError&#34;] = test_error(int_error &amp; 0x0400)

                diag[&#34;Eeprom&#34;] = eeprom

            offset = offset + 30 + 1

        return diag

    def diagnostic(self):
        &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
        cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
        data = FeigBase._interface.transfer(1.0, bytes(cmd))
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x6E:
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return self._diagnostic_parser(data[2:])

    ####################################################################################
    ####    READER INFO API
    ####################################################################################
    def _reader_info_parser(self, mode, data):
        if mode == 0x00:
            self._reader_info[&#34;RFControllerSoftwareRevision&#34;] = hexlify(
                data[0:3]
            ).decode(&#34;ascii&#34;)
            self._reader_info[&#34;HardwareType&#34;] = hexlify(data[3:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;ReaderType&#34;] = int(data[4])
            self._reader_info[&#34;TransponderTypes&#34;] = hexlify(data[5:7]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;MaxRXBufferSize&#34;] = data[7] * 256 + data[8]
            self._reader_info[&#34;MaxTXBufferSize&#34;] = data[9] * 256 + data[10]

        elif mode == 0x05:
            self._reader_info[&#34;RFCBootloaderSoftwareRevision&#34;] = hexlify(
                data[0:2]
            ).decode(&#34;ascii&#34;)

        elif mode == 0x10:
            internal_use = (
                hexlify(data[0:2]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[2:4]).decode(&#34;ascii&#34;)
                + &#34;-&#34;
                + hexlify(data[4:6]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;InternalUse&#34;] = internal_use

            freq = &#34;&#34;
            if data[6] &amp; 0x40:
                freq += &#34;UHF,&#34;
            if data[6] &amp; 0x02:
                freq += &#34;FCC,&#34;
            if data[6] &amp; 0x01:
                freq += &#34;EU&#34;
            self._reader_info[&#34;Frequency&#34;] = freq

            prt = &#34;&#34;
            if data[7] &amp; 0x01:
                prt += &#34;SERIAL,&#34;
            if data[7] &amp; 0x04:
                prt += &#34;LAN,&#34;
            if data[7] &amp; 0x10:
                prt += &#34;USB,&#34;
            if data[7] &amp; 0x80:
                prt += &#34;DISCOVERY&#34;
            self._reader_info[&#34;SupportedPorts&#34;] = prt

        elif mode == 0x15:
            self._reader_info[&#34;RFStackSoftwareRevision&#34;] = hexlify(data[0:2]).decode(
                &#34;ascii&#34;
            )

        elif mode == 0x40:
            self._reader_info[&#34;ReadPages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;ReadPermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x41:
            self._reader_info[&#34;WritePages&#34;] = data[0] * 256 + data[1]
            self._reader_info[&#34;WritePermission&#34;] = hexlify(data[2:10]).decode(&#34;ascii&#34;)

        elif mode == 0x50:
            mac = (
                hexlify(data[1:2]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[2:3]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[3:4]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[4:5]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[5:6]).decode(&#34;ascii&#34;)
                + &#34;:&#34;
                + hexlify(data[6:7]).decode(&#34;ascii&#34;)
            )
            self._reader_info[&#34;MACAddress&#34;] = mac

            if data[7] &amp; 0x01:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;Off&#34;
            else:
                self._reader_info[&#34;AutoNegotiation&#34;] = &#34;On&#34;

            if data[7] &amp; 0x02:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Full Duplex&#34;
            else:
                self._reader_info[&#34;DuplexMode&#34;] = &#34;Half Duplex&#34;

            if data[7] &amp; 0x04:
                self._reader_info[&#34;Speed&#34;] = &#34;100 Mbit&#34;
            else:
                self._reader_info[&#34;Speed&#34;] = &#34;10 Mbit&#34;

        elif mode == 0x51:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                ip = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Address&#34;] = ip
            else:
                self._reader_info[&#34;IPv4Address&#34;] = &#34;NA&#34;

        elif mode == 0x52:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                nm = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Netmask&#34;] = nm
            else:
                self._reader_info[&#34;IPv4Netmask&#34;] = &#34;NA&#34;

        elif mode == 0x53:
            if (data[0] &amp; 0x02) == 0x02:  # IPv4 Supported
                gw = (
                    str(data[1])
                    + &#34;.&#34;
                    + str(data[2])
                    + &#34;.&#34;
                    + str(data[3])
                    + &#34;.&#34;
                    + str(data[4])
                )
                self._reader_info[&#34;IPv4Gateway&#34;] = gw
            else:
                self._reader_info[&#34;IPv4Gateway&#34;] = &#34;NA&#34;

        elif mode == 0x80:
            self._reader_info[&#34;DeviceID&#34;] = hexlify(data[0:4]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;CustomerID&#34;] = hexlify(data[4:8]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;FirmwareVersion&#34;] = hexlify(data[8:10]).decode(&#34;ascii&#34;)
            self._reader_info[&#34;TransponderDriver&#34;] = hexlify(data[10:12]).decode(
                &#34;ascii&#34;
            )
            self._reader_info[&#34;FirmwareFunctions&#34;] = hexlify(data[12:14]).decode(
                &#34;ascii&#34;
            )

    def get_reader_info(self):
        &#34;&#34;&#34;Get complete reader information
        &#34;&#34;&#34;
        if len(self._reader_info) == 0:

            for mode in READER_INFO_MODE_LIST:
                cmd = [0x66, mode]
                data = FeigBase._interface.transfer(1.0, cmd)
                if data is None:
                    FeigBase._last_error = FeigError.COMM_TIMEOUT
                    return

                FeigBase._last_error = FeigError.INVALID_RESPONSE
                if data[0] == 0x66:
                    FeigBase._last_error = self._feig_status_parser(data[1])
                    if FeigBase._last_error is FeigError.OK:
                        self._reader_info_parser(mode, data[2:])

        return deepcopy(self._reader_info)

    def device_id(self) -&gt; str:
        &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
        return deepcopy(self._reader_info[&#34;DeviceID&#34;])

    ####################################################################################
    ####    READER CONFIGURATION API
    ####################################################################################

    def antenna_power(self, ant, pwr_in_milliwatts: int = -1):
        &#34;&#34;&#34;Change Antenna Power
        &#34;&#34;&#34;
        if not (
            ant is self.ANTENNA_No1
            or ant is self.ANTENNA_No2
            or ant is self.ANTENNA_No3
            or ant is self.ANTENNA_Internal
        ):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        # depending upon antenna read config
        if ant is self.ANTENNA_No1:
            cfg_page = 36
        else:
            cfg_page = 20

        # Get index of respective antenna
        index = 2  # default Antenna1
        if ant is self.ANTENNA_No2:
            index = 6
        elif ant is self.ANTENNA_No3:
            index = 7
        elif ant is self.ANTENNA_Internal:
            index = 8

        cfgData = self.read_config(cfg_page)
        if cfgData is None:
            return False

        if pwr_in_milliwatts == -1:
            return ANTENNA_POWER[cfgData[index]]

        # check antenna power
        # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
        if pwr_in_milliwatts &lt; 100:
            pwr = ANTENNA_POWER_REVERSE[50]
        elif 100 &lt;= pwr_in_milliwatts &lt; 200:
            pwr = ANTENNA_POWER_REVERSE[100]
        elif 200 &lt;= pwr_in_milliwatts &lt; 300:
            pwr = ANTENNA_POWER_REVERSE[200]
        elif 300 &lt;= pwr_in_milliwatts &lt; 400:
            pwr = ANTENNA_POWER_REVERSE[300]
        elif 400 &lt;= pwr_in_milliwatts &lt; 500:
            pwr = ANTENNA_POWER_REVERSE[400]
        else:  # pwr_in_milliwatts &gt;= 500:
            pwr = ANTENNA_POWER_REVERSE[500]

        cfgData[index] = pwr

        ret = self.write_config(cfg_page, cfgData)
        if ret is None:
            return False

        return True

    def antenna_rssi(self, ant, rssi):
        &#34;&#34;&#34;Change Antenna RSSI
        &#34;&#34;&#34;
        if not (
            ant is self.ANTENNA_No1
            or ant is self.ANTENNA_No2
            or ant is self.ANTENNA_No3
            or ant is self.ANTENNA_Internal
        ):
            raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

        if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
            raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

        cfgData = self.read_config(20)
        if cfgData is None:
            return False

        # update rssi
        if ant is self.ANTENNA_No1:
            cfgData[0] = rssi

        elif ant is self.ANTENNA_No2:
            cfgData[1] = rssi

        elif ant is self.ANTENNA_No3:
            cfgData[2] = rssi

        elif ant is self.ANTENNA_Internal:
            cfgData[3] = rssi

        ret = self.write_config(20, cfgData)
        if ret is None:
            return False

        return True

    def system_timer(self, timer_value=None):
        if timer_value is None:
            # get
            cmd = [0x86]
        else:
            # set
            if not isinstance(timer_value, tuple):
                raise ValueError(&#34;Invalid Argument&#34;)

            hour = timer_value[0]
            minutes = timer_value[1]
            milli = timer_value[2]
            if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
                raise ValueError(&#34;Invalid range&#34;)

            cmd = [0x85, hour, minutes, (milli &gt;&gt; 8) &amp; 0xFF, (milli &gt;&gt; 0) &amp; 0xFF]

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x85:  # Set
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        elif data[0] == 0x86:  # Get
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return data[2], data[3], (data[4] * 256 + data[5])

    def system_date_time(self, date_value=None, timer_value=None):
        if date_value is None and timer_value is None:
            # get
            cmd = [0x88]
        else:
            # set
            if not isinstance(date_value, tuple):
                raise ValueError(&#34;Invalid Argument {}&#34;.format(date_value))
            if not isinstance(timer_value, tuple):
                raise ValueError(&#34;Invalid Argument {}&#34;.format(timer_value))

            century = date_value[0]
            year = date_value[1]
            month = date_value[2]
            day = date_value[3]
            timezone = date_value[4]
            if (
                (century &gt; 99)
                or (year &gt; 99)
                or ((month &lt; 1) or (month &gt; 12))
                or ((day &lt; 1) or (day &gt; 31))
                or (timezone &gt; 23)
            ):
                raise ValueError(&#34;Invalid range&#34;)

            hour = timer_value[0]
            minutes = timer_value[1]
            milli = timer_value[2]
            if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
                raise ValueError(&#34;Invalid range&#34;)

            cmd = [
                0x87,
                century,
                year,
                month,
                day,
                timezone,
                hour,
                minutes,
                (milli &gt;&gt; 8) &amp; 0xFF,
                (milli &gt;&gt; 0) &amp; 0xFF,
            ]

        data = FeigBase._interface.transfer(1.0, cmd)
        if data is None:
            FeigBase._last_error = FeigError.COMM_TIMEOUT
            return

        FeigBase._last_error = FeigError.INVALID_RESPONSE
        if data[0] == 0x87:  # Set
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return True

        elif data[0] == 0x88:  # Get
            FeigBase._last_error = self._feig_status_parser(data[1])
            if FeigBase._last_error is FeigError.OK:
                return (
                    (data[2], data[3], data[4], data[5], data[6]),
                    (data[7], data[8], (data[9] * 256 + data[10])),
                )

    def read_mode_data(self, flags=None):
        raise NotImplementedError

    def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None):
        raise NotImplementedError

    def antenna_multiplexing(self, muxEnable=None, selectedAntennas=None):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="itekfeig.MRU102.ANTENNA_Internal"><code class="name">var <span class="ident">ANTENNA_Internal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.ANTENNA_No1"><code class="name">var <span class="ident">ANTENNA_No1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.ANTENNA_No2"><code class="name">var <span class="ident">ANTENNA_No2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.ANTENNA_No3"><code class="name">var <span class="ident">ANTENNA_No3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.ANTENNA_OFF"><code class="name">var <span class="ident">ANTENNA_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.INTERFACE_ETHERNET"><code class="name">var <span class="ident">INTERFACE_ETHERNET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.INTERFACE_SERIAL"><code class="name">var <span class="ident">INTERFACE_SERIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.MAX_ANTENNA"><code class="name">var <span class="ident">MAX_ANTENNA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.MODE_BRM"><code class="name">var <span class="ident">MODE_BRM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.MODE_HOST"><code class="name">var <span class="ident">MODE_HOST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.MODE_NOTIFICATION"><code class="name">var <span class="ident">MODE_NOTIFICATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.MODE_SCAN"><code class="name">var <span class="ident">MODE_SCAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.POWER_FULL"><code class="name">var <span class="ident">POWER_FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.POWER_LOW"><code class="name">var <span class="ident">POWER_LOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.POWER_MEDIUM"><code class="name">var <span class="ident">POWER_MEDIUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.READER_NAME"><code class="name">var <span class="ident">READER_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.READER_TYPE"><code class="name">var <span class="ident">READER_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.RSSI_MAX"><code class="name">var <span class="ident">RSSI_MAX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="itekfeig.MRU102.RSSI_MIN"><code class="name">var <span class="ident">RSSI_MIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="itekfeig.MRU102.antenna_multiplexing"><code class="name flex">
<span>def <span class="ident">antenna_multiplexing</span></span>(<span>self, muxEnable=None, selectedAntennas=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_multiplexing(self, muxEnable=None, selectedAntennas=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.antenna_power"><code class="name flex">
<span>def <span class="ident">antenna_power</span></span>(<span>self, ant, pwr_in_milliwatts:Â intÂ =Â -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna Power</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_power(self, ant, pwr_in_milliwatts: int = -1):
    &#34;&#34;&#34;Change Antenna Power
    &#34;&#34;&#34;
    if not (
        ant is self.ANTENNA_No1
        or ant is self.ANTENNA_No2
        or ant is self.ANTENNA_No3
        or ant is self.ANTENNA_Internal
    ):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    # depending upon antenna read config
    if ant is self.ANTENNA_No1:
        cfg_page = 36
    else:
        cfg_page = 20

    # Get index of respective antenna
    index = 2  # default Antenna1
    if ant is self.ANTENNA_No2:
        index = 6
    elif ant is self.ANTENNA_No3:
        index = 7
    elif ant is self.ANTENNA_Internal:
        index = 8

    cfgData = self.read_config(cfg_page)
    if cfgData is None:
        return False

    if pwr_in_milliwatts == -1:
        return ANTENNA_POWER[cfgData[index]]

    # check antenna power
    # Adjust &#39;pwr_in_milliwatts&#39; to nearest supported POWER
    if pwr_in_milliwatts &lt; 100:
        pwr = ANTENNA_POWER_REVERSE[50]
    elif 100 &lt;= pwr_in_milliwatts &lt; 200:
        pwr = ANTENNA_POWER_REVERSE[100]
    elif 200 &lt;= pwr_in_milliwatts &lt; 300:
        pwr = ANTENNA_POWER_REVERSE[200]
    elif 300 &lt;= pwr_in_milliwatts &lt; 400:
        pwr = ANTENNA_POWER_REVERSE[300]
    elif 400 &lt;= pwr_in_milliwatts &lt; 500:
        pwr = ANTENNA_POWER_REVERSE[400]
    else:  # pwr_in_milliwatts &gt;= 500:
        pwr = ANTENNA_POWER_REVERSE[500]

    cfgData[index] = pwr

    ret = self.write_config(cfg_page, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.antenna_rssi"><code class="name flex">
<span>def <span class="ident">antenna_rssi</span></span>(<span>self, ant, rssi)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Antenna RSSI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antenna_rssi(self, ant, rssi):
    &#34;&#34;&#34;Change Antenna RSSI
    &#34;&#34;&#34;
    if not (
        ant is self.ANTENNA_No1
        or ant is self.ANTENNA_No2
        or ant is self.ANTENNA_No3
        or ant is self.ANTENNA_Internal
    ):
        raise ValueError(&#34;Antenna= {0} is NOT supported&#34;.format(ant))

    if (rssi &lt; self.RSSI_MIN) or (rssi &gt; self.RSSI_MAX):
        raise ValueError(&#34;RSSI= {0} is NOT supported&#34;.format(rssi))

    cfgData = self.read_config(20)
    if cfgData is None:
        return False

    # update rssi
    if ant is self.ANTENNA_No1:
        cfgData[0] = rssi

    elif ant is self.ANTENNA_No2:
        cfgData[1] = rssi

    elif ant is self.ANTENNA_No3:
        cfgData[2] = rssi

    elif ant is self.ANTENNA_Internal:
        cfgData[3] = rssi

    ret = self.write_config(20, cfgData)
    if ret is None:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.change_mode"><code class="name flex">
<span>def <span class="ident">change_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Change Reader mode</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>one of the supporeted operating mode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Call get_last_error() for more reason</dd>
<dt><code>bool</code></dt>
<dd>If True, new mode is set in the reader</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode(self, mode):
    &#34;&#34;&#34;Change Reader mode

    Args:
        mode: one of the supporeted operating mode

    Returns:
        None: Call get_last_error() for more reason
        bool: If True, new mode is set in the reader
    &#34;&#34;&#34;
    cfgData = self.read_config(1)
    if cfgData is None:
        return False

    if cfgData[13] == mode:  # Current Mode is same
        FeigBase._last_error = FeigError.MODE_SAME
        return False

    # update mode
    cfgData[13] = mode

    ret = self.write_config(1, cfgData)
    if ret is None:
        return False

    FeigBase._current_mode = mode

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, interface, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the reader using one of its interface with given settings.
Onece the connection is established, a complete aconfiguration is read
from the reader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong></dt>
<dd>one of the supported interface</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>of selected interface</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if connection is sccessfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, interface, settings):
    &#34;&#34;&#34;Connect to the reader using one of its interface with given settings.
    Onece the connection is established, a complete aconfiguration is read
    from the reader.

    Args:
        interface: one of the supported interface
        settings: of selected interface

    Returns:
        bool: True if connection is sccessfull
    &#34;&#34;&#34;

    # Configure interface
    if interface == self.INTERFACE_SERIAL:
        from serial import PARITY_NONE, PARITY_EVEN, PARITY_ODD
        from ..interface.feig_serial import FeigSerial

        if settings[&#34;PARITY&#34;] == &#34;NONE&#34;:
            parity = PARITY_NONE
        elif settings[&#34;PARITY&#34;] == &#34;EVEN&#34;:
            parity = PARITY_EVEN
        elif settings[&#34;PARITY&#34;] == &#34;ODD&#34;:
            parity = PARITY_ODD
        else:
            raise ValueError(&#34;NotSupported:Parity&#34;)

        FeigBase._interface = FeigSerial()
        opened = FeigBase._interface.open(
            settings[&#34;PORT&#34;], settings[&#34;BAUDRATE&#34;], parity
        )
        if opened is False:
            FeigBase._last_error = FeigError.SERIAL
            err_msg = &#34;Failed to connect to {} {}&#34;.format(
                settings[&#34;PORT&#34;], FeigBase._interface.error
            )
            logger.error(err_msg)
            return False

    elif interface == self.INTERFACE_ETHERNET:
        from ..interface.feig_ethernet import FeigEthernet

        FeigBase._interface = FeigEthernet()
        opened = FeigBase._interface.open(settings[&#34;IP&#34;], settings[&#34;PORT&#34;])
        if opened is False:
            FeigBase._last_error = FeigError.ETHERNET
            return False
    else:
        raise ValueError(&#34;NotSupported:Interface&#34;)

    if FeigBase._interface.error != FeigError.OK:
        FeigBase._last_error = FeigBase._interface.error
        return False

    # Forced: Antenna OFF, if tags are present in the feild
    # connection to reader takes time or fail
    self.rf_onoff(self.ANTENNA_OFF)

    time.sleep(0.1)

    # Get reader type
    ret = self._get_reader_type()
    if not ret:
        logger.error(&#34;Failed to get reader ID&#34;)
        return False

    if ret != self.READER_TYPE:
        FeigBase._last_error = FeigError.INVALID_READER
        FeigBase._interface.close()
        FeigBase._interface = None
        err_msg = &#34;Expected ID={}, received ID={}&#34;.format(self.READER_TYPE, ret)
        logger.error(err_msg)
        return False

    # Get ALL INFO from the reader
    self.get_reader_info()

    # Get ALL CONFIGURATION from reader memory
    ret = self.read_all_config()
    if ret is None:
        return False

    time.sleep(0.1)

    # Configure operating modes
    from ..common.feig_host import FeigHost

    self.HostMode = FeigHost(FeigBase._interface, FeigBase._last_error)

    from ..common.feig_buffer_read import FeigBufferRead

    self.BufferReadMode = FeigBufferRead(FeigBase._interface, FeigBase._last_error)

    if interface == self.INTERFACE_SERIAL:
        from ..common.feig_scan import FeigScan

        self.ScanMode = FeigScan(FeigBase._interface, FeigBase._last_error)
    elif interface == self.INTERFACE_ETHERNET:
        from ..common.feig_notification import FeigNotification

        self.NotificationMode = FeigNotification(
            FeigBase._interface, FeigBase._last_error
        )

    return True</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.device_id"><code class="name flex">
<span>def <span class="ident">device_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns reader device ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_id(self) -&gt; str:
    &#34;&#34;&#34;Returns reader device ID&#34;&#34;&#34;
    return deepcopy(self._reader_info[&#34;DeviceID&#34;])</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.diagnostic"><code class="name flex">
<span>def <span class="ident">diagnostic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform reader diagnostic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagnostic(self):
    &#34;&#34;&#34;Perform reader diagnostic&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x08, 0xFF, 0x6E, 0xFF, 0x30, 0xD3]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6E:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return self._diagnostic_parser(data[2:])</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from current reader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect from current reader&#34;&#34;&#34;
    if FeigBase._interface:
        FeigBase._interface.close()</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get reader INPUT pin status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(self):
    &#34;&#34;&#34;Get reader INPUT pin status&#34;&#34;&#34;
    cmd = [0x02, 0x00, 0x07, 0xFF, 0x74, 0x66, 0x60]
    data = FeigBase._interface.transfer(1.0, bytes(cmd))
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x74:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            in1 = data[2] &amp; 0x01
            in2 = (data[2] &gt;&gt; 1) &amp; 0x01
            return in1, in2</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.get_reader_info"><code class="name flex">
<span>def <span class="ident">get_reader_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get complete reader information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reader_info(self):
    &#34;&#34;&#34;Get complete reader information
    &#34;&#34;&#34;
    if len(self._reader_info) == 0:

        for mode in READER_INFO_MODE_LIST:
            cmd = [0x66, mode]
            data = FeigBase._interface.transfer(1.0, cmd)
            if data is None:
                FeigBase._last_error = FeigError.COMM_TIMEOUT
                return

            FeigBase._last_error = FeigError.INVALID_RESPONSE
            if data[0] == 0x66:
                FeigBase._last_error = self._feig_status_parser(data[1])
                if FeigBase._last_error is FeigError.OK:
                    self._reader_info_parser(mode, data[2:])

    return deepcopy(self._reader_info)</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.read_mode_data"><code class="name flex">
<span>def <span class="ident">read_mode_data</span></span>(<span>self, flags=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_data(self, flags=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.read_mode_filter"><code class="name flex">
<span>def <span class="ident">read_mode_filter</span></span>(<span>self, transpondervalidtime=None, trid=None, inevflt=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mode_filter(self, transpondervalidtime=None, trid=None, inevflt=None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.rf_onoff"><code class="name flex">
<span>def <span class="ident">rf_onoff</span></span>(<span>self, antno, maintainhost=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn ON/OFF individual antenna</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rf_onoff(self, antno, maintainhost=False):
    &#34;&#34;&#34;Turn ON/OFF individual antenna&#34;&#34;&#34;
    rf_output = 0
    if maintainhost is True:
        rf_output += 0x80
    rf_output += antno

    cmd = [0x6A, rf_output]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x6A:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, out_rec:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set/Configure Digital Output or Relay pins</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>out_rec</code></strong></dt>
<dd>key,value as per following format
{
'type': str, 'digital' or 'relay',
'pin': int,
'mode': 'on' or 'off' or 'flash',
'freq': int, 1,2,4,8 Hz
'time': int, 1 to 65535 delay corresponds to multiple of 100milli
}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output(self, out_rec: dict):
    &#34;&#34;&#34;Set/Configure Digital Output or Relay pins

    Args:
        out_rec: key,value as per following format
            {
                &#39;type&#39;: str, &#39;digital&#39; or &#39;relay&#39;,
                &#39;pin&#39;: int,
                &#39;mode&#39;: &#39;on&#39; or &#39;off&#39; or &#39;flash&#39;,
                &#39;freq&#39;: int, 1,2,4,8 Hz
                &#39;time&#39;: int, 1 to 65535 delay corresponds to multiple of 100milli
            }
    &#34;&#34;&#34;
    if out_rec[&#34;type&#34;] == &#34;digital&#34;:
        out_type = 0x00
    elif out_rec[&#34;type&#34;] == &#34;relay&#34;:
        out_type = 0x80
    else:
        raise ValueError(&#34;Invalid Value&#34;)
    out_type = 0x80 + out_rec[&#34;pin&#34;]

    if out_rec[&#34;mode&#34;] == &#34;on&#34;:
        out_state = 0x01
    elif out_rec[&#34;mode&#34;] == &#34;off&#34;:
        out_state = 0x02
    elif out_rec[&#34;mode&#34;] == &#34;flash&#34;:
        out_state = 0x03
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;freq&#34;] == 1:
        out_state += 0x03 * 4
    elif out_rec[&#34;freq&#34;] == 2:
        out_state += 0x02 * 4
    elif out_rec[&#34;freq&#34;] == 4:
        out_state += 0x01 * 4
    elif out_rec[&#34;freq&#34;] == 8:
        out_state += 0x00 * 4
    else:
        raise ValueError(&#34;Invalid Value&#34;)

    if out_rec[&#34;time&#34;] &lt; 1 or out_rec[&#34;time&#34;] &gt; 65535:
        raise ValueError(&#34;Invalid Value&#34;)
    out_time = out_rec[&#34;time&#34;]

    cmd = [
        0x72,
        0x01,
        0x01,
        out_type,
        out_state,
        (out_time &gt;&gt; 8) &amp; 0xFF,
        (out_time &gt;&gt; 0) &amp; 0xFF,
    ]
    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x72:
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.system_date_time"><code class="name flex">
<span>def <span class="ident">system_date_time</span></span>(<span>self, date_value=None, timer_value=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_date_time(self, date_value=None, timer_value=None):
    if date_value is None and timer_value is None:
        # get
        cmd = [0x88]
    else:
        # set
        if not isinstance(date_value, tuple):
            raise ValueError(&#34;Invalid Argument {}&#34;.format(date_value))
        if not isinstance(timer_value, tuple):
            raise ValueError(&#34;Invalid Argument {}&#34;.format(timer_value))

        century = date_value[0]
        year = date_value[1]
        month = date_value[2]
        day = date_value[3]
        timezone = date_value[4]
        if (
            (century &gt; 99)
            or (year &gt; 99)
            or ((month &lt; 1) or (month &gt; 12))
            or ((day &lt; 1) or (day &gt; 31))
            or (timezone &gt; 23)
        ):
            raise ValueError(&#34;Invalid range&#34;)

        hour = timer_value[0]
        minutes = timer_value[1]
        milli = timer_value[2]
        if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
            raise ValueError(&#34;Invalid range&#34;)

        cmd = [
            0x87,
            century,
            year,
            month,
            day,
            timezone,
            hour,
            minutes,
            (milli &gt;&gt; 8) &amp; 0xFF,
            (milli &gt;&gt; 0) &amp; 0xFF,
        ]

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x87:  # Set
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    elif data[0] == 0x88:  # Get
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return (
                (data[2], data[3], data[4], data[5], data[6]),
                (data[7], data[8], (data[9] * 256 + data[10])),
            )</code></pre>
</details>
</dd>
<dt id="itekfeig.MRU102.system_timer"><code class="name flex">
<span>def <span class="ident">system_timer</span></span>(<span>self, timer_value=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_timer(self, timer_value=None):
    if timer_value is None:
        # get
        cmd = [0x86]
    else:
        # set
        if not isinstance(timer_value, tuple):
            raise ValueError(&#34;Invalid Argument&#34;)

        hour = timer_value[0]
        minutes = timer_value[1]
        milli = timer_value[2]
        if (hour &gt; 23) or (minutes &gt; 59) or (milli &gt; 59999):
            raise ValueError(&#34;Invalid range&#34;)

        cmd = [0x85, hour, minutes, (milli &gt;&gt; 8) &amp; 0xFF, (milli &gt;&gt; 0) &amp; 0xFF]

    data = FeigBase._interface.transfer(1.0, cmd)
    if data is None:
        FeigBase._last_error = FeigError.COMM_TIMEOUT
        return

    FeigBase._last_error = FeigError.INVALID_RESPONSE
    if data[0] == 0x85:  # Set
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return True

    elif data[0] == 0x86:  # Get
        FeigBase._last_error = self._feig_status_parser(data[1])
        if FeigBase._last_error is FeigError.OK:
            return data[2], data[3], (data[4] * 256 + data[5])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="itekfeig.common.feig_base.FeigBase" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase">FeigBase</a></b></code>:
<ul class="hlist">
<li><code><a title="itekfeig.common.feig_base.FeigBase.add_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.add_filter">add_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error">get_last_error</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_last_error_str" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_last_error_str">get_last_error_str</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.get_software_version" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.get_software_version">get_software_version</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.login" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.login">login</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_all_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_all_config">read_all_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.read_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.read_config">read_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.remove_filter" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.remove_filter">remove_filter</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.reset_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.reset_config">reset_config</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_controller_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_controller_reset">rf_controller_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.rf_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.rf_reset">rf_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.system_reset" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.system_reset">system_reset</a></code></li>
<li><code><a title="itekfeig.common.feig_base.FeigBase.write_config" href="common/feig_base.html#itekfeig.common.feig_base.FeigBase.write_config">write_config</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="itekfeig.common" href="common/index.html">itekfeig.common</a></code></li>
<li><code><a title="itekfeig.gs1" href="gs1.html">itekfeig.gs1</a></code></li>
<li><code><a title="itekfeig.interface" href="interface/index.html">itekfeig.interface</a></code></li>
<li><code><a title="itekfeig.readers" href="readers/index.html">itekfeig.readers</a></code></li>
<li><code><a title="itekfeig.version" href="version.html">itekfeig.version</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="itekfeig.SUPPORTED_READERS" href="#itekfeig.SUPPORTED_READERS">SUPPORTED_READERS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="itekfeig.FeigLogger" href="#itekfeig.FeigLogger">FeigLogger</a></code></li>
<li><code><a title="itekfeig.FeigReader" href="#itekfeig.FeigReader">FeigReader</a></code></li>
<li><code><a title="itekfeig.gtin_check" href="#itekfeig.gtin_check">gtin_check</a></code></li>
<li><code><a title="itekfeig.sgtin96_to_ean" href="#itekfeig.sgtin96_to_ean">sgtin96_to_ean</a></code></li>
<li><code><a title="itekfeig.tid_parser" href="#itekfeig.tid_parser">tid_parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="itekfeig.FeigError" href="#itekfeig.FeigError">FeigError</a></code></h4>
<ul class="">
<li><code><a title="itekfeig.FeigError.ADDRESS_ERROR" href="#itekfeig.FeigError.ADDRESS_ERROR">ADDRESS_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.AUTHENT_ERROR" href="#itekfeig.FeigError.AUTHENT_ERROR">AUTHENT_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.COMMAND_NOT_AVAILABLE" href="#itekfeig.FeigError.COMMAND_NOT_AVAILABLE">COMMAND_NOT_AVAILABLE</a></code></li>
<li><code><a title="itekfeig.FeigError.COMM_TIMEOUT" href="#itekfeig.FeigError.COMM_TIMEOUT">COMM_TIMEOUT</a></code></li>
<li><code><a title="itekfeig.FeigError.CONNECTION_REFUSED" href="#itekfeig.FeigError.CONNECTION_REFUSED">CONNECTION_REFUSED</a></code></li>
<li><code><a title="itekfeig.FeigError.DATA_BUFFER_OVERFLOW" href="#itekfeig.FeigError.DATA_BUFFER_OVERFLOW">DATA_BUFFER_OVERFLOW</a></code></li>
<li><code><a title="itekfeig.FeigError.DATA_FALSE" href="#itekfeig.FeigError.DATA_FALSE">DATA_FALSE</a></code></li>
<li><code><a title="itekfeig.FeigError.EEPROM_FAILURE" href="#itekfeig.FeigError.EEPROM_FAILURE">EEPROM_FAILURE</a></code></li>
<li><code><a title="itekfeig.FeigError.EPC_LEN_MISMATCH" href="#itekfeig.FeigError.EPC_LEN_MISMATCH">EPC_LEN_MISMATCH</a></code></li>
<li><code><a title="itekfeig.FeigError.ETHERNET" href="#itekfeig.FeigError.ETHERNET">ETHERNET</a></code></li>
<li><code><a title="itekfeig.FeigError.FIRMWARE_ACTIVATION_REQUIRED" href="#itekfeig.FeigError.FIRMWARE_ACTIVATION_REQUIRED">FIRMWARE_ACTIVATION_REQUIRED</a></code></li>
<li><code><a title="itekfeig.FeigError.HARDWARE_WARNING" href="#itekfeig.FeigError.HARDWARE_WARNING">HARDWARE_WARNING</a></code></li>
<li><code><a title="itekfeig.FeigError.INTERFACE_ERROR" href="#itekfeig.FeigError.INTERFACE_ERROR">INTERFACE_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.INVALID_INTERFACE" href="#itekfeig.FeigError.INVALID_INTERFACE">INVALID_INTERFACE</a></code></li>
<li><code><a title="itekfeig.FeigError.INVALID_MODE" href="#itekfeig.FeigError.INVALID_MODE">INVALID_MODE</a></code></li>
<li><code><a title="itekfeig.FeigError.INVALID_READER" href="#itekfeig.FeigError.INVALID_READER">INVALID_READER</a></code></li>
<li><code><a title="itekfeig.FeigError.INVALID_RESPONSE" href="#itekfeig.FeigError.INVALID_RESPONSE">INVALID_RESPONSE</a></code></li>
<li><code><a title="itekfeig.FeigError.LENGTH_ERROR" href="#itekfeig.FeigError.LENGTH_ERROR">LENGTH_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.LOGIN_ERROR" href="#itekfeig.FeigError.LOGIN_ERROR">LOGIN_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.LOGIN_REQUEST" href="#itekfeig.FeigError.LOGIN_REQUEST">LOGIN_REQUEST</a></code></li>
<li><code><a title="itekfeig.FeigError.MODE_SAME" href="#itekfeig.FeigError.MODE_SAME">MODE_SAME</a></code></li>
<li><code><a title="itekfeig.FeigError.MORE_DATA" href="#itekfeig.FeigError.MORE_DATA">MORE_DATA</a></code></li>
<li><code><a title="itekfeig.FeigError.NO_ROUTE_TO_HOST" href="#itekfeig.FeigError.NO_ROUTE_TO_HOST">NO_ROUTE_TO_HOST</a></code></li>
<li><code><a title="itekfeig.FeigError.NO_TAG" href="#itekfeig.FeigError.NO_TAG">NO_TAG</a></code></li>
<li><code><a title="itekfeig.FeigError.NO_VALID_DATA" href="#itekfeig.FeigError.NO_VALID_DATA">NO_VALID_DATA</a></code></li>
<li><code><a title="itekfeig.FeigError.OK" href="#itekfeig.FeigError.OK">OK</a></code></li>
<li><code><a title="itekfeig.FeigError.PARAMETER_RANGE_ERROR" href="#itekfeig.FeigError.PARAMETER_RANGE_ERROR">PARAMETER_RANGE_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.READ_PROTECT" href="#itekfeig.FeigError.READ_PROTECT">READ_PROTECT</a></code></li>
<li><code><a title="itekfeig.FeigError.RF_COMMUNICATION_ERROR" href="#itekfeig.FeigError.RF_COMMUNICATION_ERROR">RF_COMMUNICATION_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.RF_WARNING" href="#itekfeig.FeigError.RF_WARNING">RF_WARNING</a></code></li>
<li><code><a title="itekfeig.FeigError.SERIAL" href="#itekfeig.FeigError.SERIAL">SERIAL</a></code></li>
<li><code><a title="itekfeig.FeigError.TAG_ERROR" href="#itekfeig.FeigError.TAG_ERROR">TAG_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.UNHANDLED" href="#itekfeig.FeigError.UNHANDLED">UNHANDLED</a></code></li>
<li><code><a title="itekfeig.FeigError.UNKNOWN" href="#itekfeig.FeigError.UNKNOWN">UNKNOWN</a></code></li>
<li><code><a title="itekfeig.FeigError.UNKNOWN_COMMAND" href="#itekfeig.FeigError.UNKNOWN_COMMAND">UNKNOWN_COMMAND</a></code></li>
<li><code><a title="itekfeig.FeigError.WRITE_ERROR" href="#itekfeig.FeigError.WRITE_ERROR">WRITE_ERROR</a></code></li>
<li><code><a title="itekfeig.FeigError.WRITE_PROTECT" href="#itekfeig.FeigError.WRITE_PROTECT">WRITE_PROTECT</a></code></li>
<li><code><a title="itekfeig.FeigError.WRONG_FIRMWARE" href="#itekfeig.FeigError.WRONG_FIRMWARE">WRONG_FIRMWARE</a></code></li>
<li><code><a title="itekfeig.FeigError.WRONG_TRANSPONDER_TYPE" href="#itekfeig.FeigError.WRONG_TRANSPONDER_TYPE">WRONG_TRANSPONDER_TYPE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="itekfeig.HyWear" href="#itekfeig.HyWear">HyWear</a></code></h4>
<ul class="">
<li><code><a title="itekfeig.HyWear.ANTENNA_OFF" href="#itekfeig.HyWear.ANTENNA_OFF">ANTENNA_OFF</a></code></li>
<li><code><a title="itekfeig.HyWear.ANTENNA_ON" href="#itekfeig.HyWear.ANTENNA_ON">ANTENNA_ON</a></code></li>
<li><code><a title="itekfeig.HyWear.INTERFACE_ETHERNET" href="#itekfeig.HyWear.INTERFACE_ETHERNET">INTERFACE_ETHERNET</a></code></li>
<li><code><a title="itekfeig.HyWear.INTERFACE_SERIAL" href="#itekfeig.HyWear.INTERFACE_SERIAL">INTERFACE_SERIAL</a></code></li>
<li><code><a title="itekfeig.HyWear.LED_BLUE" href="#itekfeig.HyWear.LED_BLUE">LED_BLUE</a></code></li>
<li><code><a title="itekfeig.HyWear.LED_GREEN" href="#itekfeig.HyWear.LED_GREEN">LED_GREEN</a></code></li>
<li><code><a title="itekfeig.HyWear.LED_RED" href="#itekfeig.HyWear.LED_RED">LED_RED</a></code></li>
<li><code><a title="itekfeig.HyWear.LED_YELLOW" href="#itekfeig.HyWear.LED_YELLOW">LED_YELLOW</a></code></li>
<li><code><a title="itekfeig.HyWear.MODE_HOST" href="#itekfeig.HyWear.MODE_HOST">MODE_HOST</a></code></li>
<li><code><a title="itekfeig.HyWear.MODE_NOTIFICATION" href="#itekfeig.HyWear.MODE_NOTIFICATION">MODE_NOTIFICATION</a></code></li>
<li><code><a title="itekfeig.HyWear.POWER_FULL" href="#itekfeig.HyWear.POWER_FULL">POWER_FULL</a></code></li>
<li><code><a title="itekfeig.HyWear.POWER_LOW" href="#itekfeig.HyWear.POWER_LOW">POWER_LOW</a></code></li>
<li><code><a title="itekfeig.HyWear.POWER_MEDIUM" href="#itekfeig.HyWear.POWER_MEDIUM">POWER_MEDIUM</a></code></li>
<li><code><a title="itekfeig.HyWear.READER_NAME" href="#itekfeig.HyWear.READER_NAME">READER_NAME</a></code></li>
<li><code><a title="itekfeig.HyWear.READER_TYPE" href="#itekfeig.HyWear.READER_TYPE">READER_TYPE</a></code></li>
<li><code><a title="itekfeig.HyWear.adjust_scanmode" href="#itekfeig.HyWear.adjust_scanmode">adjust_scanmode</a></code></li>
<li><code><a title="itekfeig.HyWear.configuration_parser" href="#itekfeig.HyWear.configuration_parser">configuration_parser</a></code></li>
<li><code><a title="itekfeig.HyWear.connect" href="#itekfeig.HyWear.connect">connect</a></code></li>
<li><code><a title="itekfeig.HyWear.device_id" href="#itekfeig.HyWear.device_id">device_id</a></code></li>
<li><code><a title="itekfeig.HyWear.diagnostic" href="#itekfeig.HyWear.diagnostic">diagnostic</a></code></li>
<li><code><a title="itekfeig.HyWear.disconnect" href="#itekfeig.HyWear.disconnect">disconnect</a></code></li>
<li><code><a title="itekfeig.HyWear.get_reader_info" href="#itekfeig.HyWear.get_reader_info">get_reader_info</a></code></li>
<li><code><a title="itekfeig.HyWear.rf_onoff" href="#itekfeig.HyWear.rf_onoff">rf_onoff</a></code></li>
<li><code><a title="itekfeig.HyWear.set_output" href="#itekfeig.HyWear.set_output">set_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="itekfeig.LRU1002" href="#itekfeig.LRU1002">LRU1002</a></code></h4>
<ul class="">
<li><code><a title="itekfeig.LRU1002.ANTENNA_No1" href="#itekfeig.LRU1002.ANTENNA_No1">ANTENNA_No1</a></code></li>
<li><code><a title="itekfeig.LRU1002.ANTENNA_No2" href="#itekfeig.LRU1002.ANTENNA_No2">ANTENNA_No2</a></code></li>
<li><code><a title="itekfeig.LRU1002.ANTENNA_No3" href="#itekfeig.LRU1002.ANTENNA_No3">ANTENNA_No3</a></code></li>
<li><code><a title="itekfeig.LRU1002.ANTENNA_No4" href="#itekfeig.LRU1002.ANTENNA_No4">ANTENNA_No4</a></code></li>
<li><code><a title="itekfeig.LRU1002.ANTENNA_OFF" href="#itekfeig.LRU1002.ANTENNA_OFF">ANTENNA_OFF</a></code></li>
<li><code><a title="itekfeig.LRU1002.INTERFACE_ETHERNET" href="#itekfeig.LRU1002.INTERFACE_ETHERNET">INTERFACE_ETHERNET</a></code></li>
<li><code><a title="itekfeig.LRU1002.INTERFACE_SERIAL" href="#itekfeig.LRU1002.INTERFACE_SERIAL">INTERFACE_SERIAL</a></code></li>
<li><code><a title="itekfeig.LRU1002.MAX_ANTENNA" href="#itekfeig.LRU1002.MAX_ANTENNA">MAX_ANTENNA</a></code></li>
<li><code><a title="itekfeig.LRU1002.MODE_BRM" href="#itekfeig.LRU1002.MODE_BRM">MODE_BRM</a></code></li>
<li><code><a title="itekfeig.LRU1002.MODE_HOST" href="#itekfeig.LRU1002.MODE_HOST">MODE_HOST</a></code></li>
<li><code><a title="itekfeig.LRU1002.MODE_NOTIFICATION" href="#itekfeig.LRU1002.MODE_NOTIFICATION">MODE_NOTIFICATION</a></code></li>
<li><code><a title="itekfeig.LRU1002.MODE_SCAN" href="#itekfeig.LRU1002.MODE_SCAN">MODE_SCAN</a></code></li>
<li><code><a title="itekfeig.LRU1002.POWER_FULL" href="#itekfeig.LRU1002.POWER_FULL">POWER_FULL</a></code></li>
<li><code><a title="itekfeig.LRU1002.POWER_LOW" href="#itekfeig.LRU1002.POWER_LOW">POWER_LOW</a></code></li>
<li><code><a title="itekfeig.LRU1002.POWER_MEDIUM" href="#itekfeig.LRU1002.POWER_MEDIUM">POWER_MEDIUM</a></code></li>
<li><code><a title="itekfeig.LRU1002.READER_NAME" href="#itekfeig.LRU1002.READER_NAME">READER_NAME</a></code></li>
<li><code><a title="itekfeig.LRU1002.READER_TYPE" href="#itekfeig.LRU1002.READER_TYPE">READER_TYPE</a></code></li>
<li><code><a title="itekfeig.LRU1002.RSSI_MAX" href="#itekfeig.LRU1002.RSSI_MAX">RSSI_MAX</a></code></li>
<li><code><a title="itekfeig.LRU1002.RSSI_MIN" href="#itekfeig.LRU1002.RSSI_MIN">RSSI_MIN</a></code></li>
<li><code><a title="itekfeig.LRU1002.antenna_multiplexing" href="#itekfeig.LRU1002.antenna_multiplexing">antenna_multiplexing</a></code></li>
<li><code><a title="itekfeig.LRU1002.antenna_power" href="#itekfeig.LRU1002.antenna_power">antenna_power</a></code></li>
<li><code><a title="itekfeig.LRU1002.antenna_rssi" href="#itekfeig.LRU1002.antenna_rssi">antenna_rssi</a></code></li>
<li><code><a title="itekfeig.LRU1002.change_mode" href="#itekfeig.LRU1002.change_mode">change_mode</a></code></li>
<li><code><a title="itekfeig.LRU1002.connect" href="#itekfeig.LRU1002.connect">connect</a></code></li>
<li><code><a title="itekfeig.LRU1002.device_id" href="#itekfeig.LRU1002.device_id">device_id</a></code></li>
<li><code><a title="itekfeig.LRU1002.diagnostic" href="#itekfeig.LRU1002.diagnostic">diagnostic</a></code></li>
<li><code><a title="itekfeig.LRU1002.disconnect" href="#itekfeig.LRU1002.disconnect">disconnect</a></code></li>
<li><code><a title="itekfeig.LRU1002.get_input" href="#itekfeig.LRU1002.get_input">get_input</a></code></li>
<li><code><a title="itekfeig.LRU1002.get_reader_info" href="#itekfeig.LRU1002.get_reader_info">get_reader_info</a></code></li>
<li><code><a title="itekfeig.LRU1002.notification_channel" href="#itekfeig.LRU1002.notification_channel">notification_channel</a></code></li>
<li><code><a title="itekfeig.LRU1002.read_mode_data" href="#itekfeig.LRU1002.read_mode_data">read_mode_data</a></code></li>
<li><code><a title="itekfeig.LRU1002.read_mode_filter" href="#itekfeig.LRU1002.read_mode_filter">read_mode_filter</a></code></li>
<li><code><a title="itekfeig.LRU1002.rf_onoff" href="#itekfeig.LRU1002.rf_onoff">rf_onoff</a></code></li>
<li><code><a title="itekfeig.LRU1002.set_output" href="#itekfeig.LRU1002.set_output">set_output</a></code></li>
<li><code><a title="itekfeig.LRU1002.system_date_time" href="#itekfeig.LRU1002.system_date_time">system_date_time</a></code></li>
<li><code><a title="itekfeig.LRU1002.system_timer" href="#itekfeig.LRU1002.system_timer">system_timer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="itekfeig.LRU500i" href="#itekfeig.LRU500i">LRU500i</a></code></h4>
<ul class="">
<li><code><a title="itekfeig.LRU500i.ANTENNA_No1" href="#itekfeig.LRU500i.ANTENNA_No1">ANTENNA_No1</a></code></li>
<li><code><a title="itekfeig.LRU500i.ANTENNA_No2" href="#itekfeig.LRU500i.ANTENNA_No2">ANTENNA_No2</a></code></li>
<li><code><a title="itekfeig.LRU500i.ANTENNA_OFF" href="#itekfeig.LRU500i.ANTENNA_OFF">ANTENNA_OFF</a></code></li>
<li><code><a title="itekfeig.LRU500i.INTERFACE_ETHERNET" href="#itekfeig.LRU500i.INTERFACE_ETHERNET">INTERFACE_ETHERNET</a></code></li>
<li><code><a title="itekfeig.LRU500i.INTERFACE_SERIAL" href="#itekfeig.LRU500i.INTERFACE_SERIAL">INTERFACE_SERIAL</a></code></li>
<li><code><a title="itekfeig.LRU500i.MAX_ANTENNA" href="#itekfeig.LRU500i.MAX_ANTENNA">MAX_ANTENNA</a></code></li>
<li><code><a title="itekfeig.LRU500i.MODE_BRM" href="#itekfeig.LRU500i.MODE_BRM">MODE_BRM</a></code></li>
<li><code><a title="itekfeig.LRU500i.MODE_HOST" href="#itekfeig.LRU500i.MODE_HOST">MODE_HOST</a></code></li>
<li><code><a title="itekfeig.LRU500i.MODE_NOTIFICATION" href="#itekfeig.LRU500i.MODE_NOTIFICATION">MODE_NOTIFICATION</a></code></li>
<li><code><a title="itekfeig.LRU500i.MODE_SCAN" href="#itekfeig.LRU500i.MODE_SCAN">MODE_SCAN</a></code></li>
<li><code><a title="itekfeig.LRU500i.POWER_FULL" href="#itekfeig.LRU500i.POWER_FULL">POWER_FULL</a></code></li>
<li><code><a title="itekfeig.LRU500i.POWER_LOW" href="#itekfeig.LRU500i.POWER_LOW">POWER_LOW</a></code></li>
<li><code><a title="itekfeig.LRU500i.POWER_MEDIUM" href="#itekfeig.LRU500i.POWER_MEDIUM">POWER_MEDIUM</a></code></li>
<li><code><a title="itekfeig.LRU500i.READER_NAME" href="#itekfeig.LRU500i.READER_NAME">READER_NAME</a></code></li>
<li><code><a title="itekfeig.LRU500i.READER_TYPE" href="#itekfeig.LRU500i.READER_TYPE">READER_TYPE</a></code></li>
<li><code><a title="itekfeig.LRU500i.RSSI_MAX" href="#itekfeig.LRU500i.RSSI_MAX">RSSI_MAX</a></code></li>
<li><code><a title="itekfeig.LRU500i.RSSI_MIN" href="#itekfeig.LRU500i.RSSI_MIN">RSSI_MIN</a></code></li>
<li><code><a title="itekfeig.LRU500i.antenna_multiplexing" href="#itekfeig.LRU500i.antenna_multiplexing">antenna_multiplexing</a></code></li>
<li><code><a title="itekfeig.LRU500i.antenna_power" href="#itekfeig.LRU500i.antenna_power">antenna_power</a></code></li>
<li><code><a title="itekfeig.LRU500i.antenna_rssi" href="#itekfeig.LRU500i.antenna_rssi">antenna_rssi</a></code></li>
<li><code><a title="itekfeig.LRU500i.change_mode" href="#itekfeig.LRU500i.change_mode">change_mode</a></code></li>
<li><code><a title="itekfeig.LRU500i.connect" href="#itekfeig.LRU500i.connect">connect</a></code></li>
<li><code><a title="itekfeig.LRU500i.device_id" href="#itekfeig.LRU500i.device_id">device_id</a></code></li>
<li><code><a title="itekfeig.LRU500i.diagnostic" href="#itekfeig.LRU500i.diagnostic">diagnostic</a></code></li>
<li><code><a title="itekfeig.LRU500i.disconnect" href="#itekfeig.LRU500i.disconnect">disconnect</a></code></li>
<li><code><a title="itekfeig.LRU500i.get_input" href="#itekfeig.LRU500i.get_input">get_input</a></code></li>
<li><code><a title="itekfeig.LRU500i.get_reader_info" href="#itekfeig.LRU500i.get_reader_info">get_reader_info</a></code></li>
<li><code><a title="itekfeig.LRU500i.notification_channel" href="#itekfeig.LRU500i.notification_channel">notification_channel</a></code></li>
<li><code><a title="itekfeig.LRU500i.read_mode_data" href="#itekfeig.LRU500i.read_mode_data">read_mode_data</a></code></li>
<li><code><a title="itekfeig.LRU500i.read_mode_filter" href="#itekfeig.LRU500i.read_mode_filter">read_mode_filter</a></code></li>
<li><code><a title="itekfeig.LRU500i.rf_onoff" href="#itekfeig.LRU500i.rf_onoff">rf_onoff</a></code></li>
<li><code><a title="itekfeig.LRU500i.set_output" href="#itekfeig.LRU500i.set_output">set_output</a></code></li>
<li><code><a title="itekfeig.LRU500i.signaler" href="#itekfeig.LRU500i.signaler">signaler</a></code></li>
<li><code><a title="itekfeig.LRU500i.system_date_time" href="#itekfeig.LRU500i.system_date_time">system_date_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="itekfeig.MRU102" href="#itekfeig.MRU102">MRU102</a></code></h4>
<ul class="">
<li><code><a title="itekfeig.MRU102.ANTENNA_Internal" href="#itekfeig.MRU102.ANTENNA_Internal">ANTENNA_Internal</a></code></li>
<li><code><a title="itekfeig.MRU102.ANTENNA_No1" href="#itekfeig.MRU102.ANTENNA_No1">ANTENNA_No1</a></code></li>
<li><code><a title="itekfeig.MRU102.ANTENNA_No2" href="#itekfeig.MRU102.ANTENNA_No2">ANTENNA_No2</a></code></li>
<li><code><a title="itekfeig.MRU102.ANTENNA_No3" href="#itekfeig.MRU102.ANTENNA_No3">ANTENNA_No3</a></code></li>
<li><code><a title="itekfeig.MRU102.ANTENNA_OFF" href="#itekfeig.MRU102.ANTENNA_OFF">ANTENNA_OFF</a></code></li>
<li><code><a title="itekfeig.MRU102.INTERFACE_ETHERNET" href="#itekfeig.MRU102.INTERFACE_ETHERNET">INTERFACE_ETHERNET</a></code></li>
<li><code><a title="itekfeig.MRU102.INTERFACE_SERIAL" href="#itekfeig.MRU102.INTERFACE_SERIAL">INTERFACE_SERIAL</a></code></li>
<li><code><a title="itekfeig.MRU102.MAX_ANTENNA" href="#itekfeig.MRU102.MAX_ANTENNA">MAX_ANTENNA</a></code></li>
<li><code><a title="itekfeig.MRU102.MODE_BRM" href="#itekfeig.MRU102.MODE_BRM">MODE_BRM</a></code></li>
<li><code><a title="itekfeig.MRU102.MODE_HOST" href="#itekfeig.MRU102.MODE_HOST">MODE_HOST</a></code></li>
<li><code><a title="itekfeig.MRU102.MODE_NOTIFICATION" href="#itekfeig.MRU102.MODE_NOTIFICATION">MODE_NOTIFICATION</a></code></li>
<li><code><a title="itekfeig.MRU102.MODE_SCAN" href="#itekfeig.MRU102.MODE_SCAN">MODE_SCAN</a></code></li>
<li><code><a title="itekfeig.MRU102.POWER_FULL" href="#itekfeig.MRU102.POWER_FULL">POWER_FULL</a></code></li>
<li><code><a title="itekfeig.MRU102.POWER_LOW" href="#itekfeig.MRU102.POWER_LOW">POWER_LOW</a></code></li>
<li><code><a title="itekfeig.MRU102.POWER_MEDIUM" href="#itekfeig.MRU102.POWER_MEDIUM">POWER_MEDIUM</a></code></li>
<li><code><a title="itekfeig.MRU102.READER_NAME" href="#itekfeig.MRU102.READER_NAME">READER_NAME</a></code></li>
<li><code><a title="itekfeig.MRU102.READER_TYPE" href="#itekfeig.MRU102.READER_TYPE">READER_TYPE</a></code></li>
<li><code><a title="itekfeig.MRU102.RSSI_MAX" href="#itekfeig.MRU102.RSSI_MAX">RSSI_MAX</a></code></li>
<li><code><a title="itekfeig.MRU102.RSSI_MIN" href="#itekfeig.MRU102.RSSI_MIN">RSSI_MIN</a></code></li>
<li><code><a title="itekfeig.MRU102.antenna_multiplexing" href="#itekfeig.MRU102.antenna_multiplexing">antenna_multiplexing</a></code></li>
<li><code><a title="itekfeig.MRU102.antenna_power" href="#itekfeig.MRU102.antenna_power">antenna_power</a></code></li>
<li><code><a title="itekfeig.MRU102.antenna_rssi" href="#itekfeig.MRU102.antenna_rssi">antenna_rssi</a></code></li>
<li><code><a title="itekfeig.MRU102.change_mode" href="#itekfeig.MRU102.change_mode">change_mode</a></code></li>
<li><code><a title="itekfeig.MRU102.connect" href="#itekfeig.MRU102.connect">connect</a></code></li>
<li><code><a title="itekfeig.MRU102.device_id" href="#itekfeig.MRU102.device_id">device_id</a></code></li>
<li><code><a title="itekfeig.MRU102.diagnostic" href="#itekfeig.MRU102.diagnostic">diagnostic</a></code></li>
<li><code><a title="itekfeig.MRU102.disconnect" href="#itekfeig.MRU102.disconnect">disconnect</a></code></li>
<li><code><a title="itekfeig.MRU102.get_input" href="#itekfeig.MRU102.get_input">get_input</a></code></li>
<li><code><a title="itekfeig.MRU102.get_reader_info" href="#itekfeig.MRU102.get_reader_info">get_reader_info</a></code></li>
<li><code><a title="itekfeig.MRU102.read_mode_data" href="#itekfeig.MRU102.read_mode_data">read_mode_data</a></code></li>
<li><code><a title="itekfeig.MRU102.read_mode_filter" href="#itekfeig.MRU102.read_mode_filter">read_mode_filter</a></code></li>
<li><code><a title="itekfeig.MRU102.rf_onoff" href="#itekfeig.MRU102.rf_onoff">rf_onoff</a></code></li>
<li><code><a title="itekfeig.MRU102.set_output" href="#itekfeig.MRU102.set_output">set_output</a></code></li>
<li><code><a title="itekfeig.MRU102.system_date_time" href="#itekfeig.MRU102.system_date_time">system_date_time</a></code></li>
<li><code><a title="itekfeig.MRU102.system_timer" href="#itekfeig.MRU102.system_timer">system_timer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>